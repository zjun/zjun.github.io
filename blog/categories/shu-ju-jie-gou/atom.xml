<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数据结构 | zJun's Tech Blog]]></title>
  <link href="http://zjun.github.io/blog/categories/shu-ju-jie-gou/atom.xml" rel="self"/>
  <link href="http://zjun.github.io/"/>
  <updated>2014-06-08T12:24:41+08:00</updated>
  <id>http://zjun.github.io/</id>
  <author>
    <name><![CDATA[zJun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[选择排序]]></title>
    <link href="http://zjun.github.io/blog/2006/07/13/select-sort-java/"/>
    <updated>2006-07-13T11:30:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/13/select-sort-java</id>
    <content type="html"><![CDATA[<p>选择排序的思想和插入排序差不多，都是先把排序的对象分作两组，不同点在于选择排序 将要排序的对象 <strong>分作一个是已排序的，一个是未排序的，从后端未排序部份选择一个最小值，并放入前端已排序部份的最后一个。</strong></p>

<!-- more -->


<p><strong>[例子]</strong></p>

<p>排序前： 70 80 31 37 10 <strong>1</strong> 48 60 33 80<br/>
1.      [<strong>1</strong>] 80 31 37 <strong>10</strong> 70 48 60 33 80 选出最小值 1<br/>
2.      [1 <strong>10</strong>] <strong>31</strong> 37 80 70 48 60 33 80 选出最小值 10<br/>
3.      [1 10 <strong>31</strong>] 37 80 70 48 60 <strong>33</strong> 80 选出最小值 31<br/>
4.      [1 10 31 <strong>33</strong>] 80 70 48 60 <strong>37</strong> 80 &hellip;&hellip;<br/>
5.      [1 10 31 33 <strong>37</strong>] 70 <strong>48</strong> 60 80 80 &hellip;&hellip;<br/>
6.      [1 10 31 33 37 <strong>48</strong>] 70 <strong>60</strong> 80 80 &hellip;&hellip;<br/>
7.      [1 10 31 33 37 48 <strong>60</strong>] <strong>70</strong> 80 80 &hellip;&hellip;<br/>
8.      [1 10 31 33 37 48 60 <strong>70</strong>] <strong>80</strong> 80 &hellip;&hellip;<br/>
9.      [1 10 31 33 37 48 60 70 <strong>80</strong>] 80 &hellip;&hellip;</p>

<p>[<strong>代码</strong>]</p>

<pre><code>/**   
  * 选择排序
  *   @param   data：等待排序整型数组
  *  
  *  data = {70, 81, 31, 37, 10, 1, 48, 60, 33, 80}
  *  排序结果：  
  *        第 1 次排序：81 70 31 37 10 1 48 60 33 80 
  *        第 2 次排序：81 80 31 37 10 1 48 60 33 70 
  *        第 3 次排序：81 80 70 37 10 1 48 60 33 31 
  *        第 4 次排序：81 80 70 60 10 1 48 37 33 31 
  *        第 5 次排序：81 80 70 60 48 1 10 37 33 31 
  *        第 6 次排序：81 80 70 60 48 37 10 1 33 31 
  *        第 7 次排序：81 80 70 60 48 37 33 1 10 31 
  *        第 8 次排序：81 80 70 60 48 37 33 31 10 1 
  *        第 9 次排序：81 80 70 60 48 37 33 31 10 1 
    */  
public   void  selectSort( int [] data)  {
         int  max  =  data.length;
         int  m, temp;

         for  ( int  i  =   0 ; i  &lt;  max  -   1 ; i ++ )  {
            m  =  i;
             for  ( int  j  =  i  +   1 ; j  &lt;=  max  -   1 ; j ++ )  {
                 if  (data[j]  &gt;  data[m])  {
                    m  =  j;
                }
            }

             if  (m  !=  i)  {
                temp  =  data[i];
                data[i]  =  data[m];
                data[m]  =  temp;
            }

            System.out.print( " 第  "   +  (i  +   1 )  +   "  次排序： " );
             for  ( int  k  =   0 ; k  &lt;=  max  -   1 ; k ++ )  {
                System.out.print(data[k]  +   "   " );
            }
            System.out.println();
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[插入排序]]></title>
    <link href="http://zjun.github.io/blog/2006/07/10/insert-sort-java/"/>
    <updated>2006-07-10T14:32:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/10/insert-sort-java</id>
    <content type="html"><![CDATA[<p>插入排序，好比是洗扑克一样，我们将牌分作两堆，每次从后面一堆的牌抽出最前端的牌，然后插入前面一堆牌的适当位置，例如：</p>

<p>排序前： [<strong>92</strong>], 77, 67, 8, 6, 84, 55, 85, 43, 67  &mdash; 将数组分为两部分，第一个元素为一组</p>

<!-- more -->


<p>第 1 次排序：[<strong>77 92</strong>] 67 8 6 84 55 85 43 67     &mdash; 将后一组的第一个元素 77 插入前一组的适当位置<br/>
第 2 次排序：[<strong>67 77 92</strong>] 8 6 84 55 85 43 67     &mdash; 将后一组的第一个元素 67 插入前一组的适当位置<br/>
第 3 次排序：[<strong>8 67 77 92</strong>] 6 84 55 85 43 67     &mdash; 将后一组的第一个元素 8 插入前一组的适当位置 <br/>
第 4 次排序：[<strong>6 8 67 77 92 84</strong>] 55 85 43 67      &mdash; 将后一组的第一个元素 6 插入前一组的适当位置<br/>
第 5 次排序：[<strong>6 8 67 77 84 92 55</strong>] 85 43 67      &mdash; 将后一组的第一个元素 84 插入前一组的适当位置<br/>
第 6 次排序：[<strong>6 8 55 67 77 84 92 85</strong>] 43 67      &mdash; 将后一组的第一个元素 55 插入前一组的适当位置<br/>
第 7 次排序：[<strong>6 8 55 67 77 84 85 92 43</strong>] 67      &mdash; 将后一组的第一个元素 85 插入前一组的适当位置<br/>
第 8 次排序：[<strong>6 8 43 55 67 77 84 85 92</strong>] 67      &mdash; 将后一组的第一个元素 43 插入前一组的适当位置<br/>
第 9 次排序：[<strong>6 8 43 55 67 67 77 84 85 92</strong>]      &mdash; 将后一组的第一个元素 67 插入前一组的适当位置</p>

<p><strong>Java代码实现</strong>，如下：</p>

<pre><code>/**  
  * 插入排序  
  *   @param   data：等代排序整型数组  
  *     data = { 92, 77, 67, 8, 6, 84, 55, 85, 43, 67 }  
  *     排序结果：  
  *        第 1 次排序：77 92 67 8 6 84 55 85 43 67   
  *        第 2 次排序：67 77 92 8 6 84 55 85 43 67   
  *        第 3 次排序：8 67 77 92 6 84 55 85 43 67   
  *        第 4 次排序：6 8 67 77 92 84 55 85 43 67   
  *        第 5 次排序：6 8 67 77 84 92 55 85 43 67   
  *        第 6 次排序：6 8 55 67 77 84 92 85 43 67   
  *        第 7 次排序：6 8 55 67 77 84 85 92 43 67   
  *        第 8 次排序：6 8 43 55 67 77 84 85 92 67   
  *        第 9 次排序：6 8 43 55 67 67 77 84 85 92   
    */    
public   void  insertSort( int  data[])  {
         int  k, temp, max  =  data.length;

         for  ( int  i  =   1 ; i  &lt;  max; i ++ )  {
            temp  =  data[i];  //  后一组的第一个元素
            k  =  i  -   1 ;  //  从前一组的最后一个元素开始比较
             while  (temp  &lt;  data[k])  {
                data[k  +   1 ]  =  data[k];  //  如果前一组元素大于后一组第一个元素，则后移
                k -- ;
                 if  (k  ==   - 1 )
                     break ;  //  如果前一组元素比较完，则跳出
            }
            data[k  +   1 ]  =  temp;  //  插入适当的位置

            System.out.print( "  第   "   +  i  +   "   次排序：  " );
             for  ( int  j  =   0 ; j  &lt;=  max  -   1 ; j ++ )  {
                System.out.print(data[j]  +   "     " );
            }
            System.out.println();
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[冒泡排序]]></title>
    <link href="http://zjun.github.io/blog/2006/07/10/bubble-sort-java/"/>
    <updated>2006-07-10T11:35:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/10/bubble-sort-java</id>
    <content type="html"><![CDATA[<p>冒泡排序, 顾名思义，就是排序时，最大的元素会如同气泡一样移至右端，其利用比较相邻元素的方法，将大的元素交换至右端，所以大的元素会不断的往右移动，直到适当的位置为止。</p>

<!-- more -->


<p>基本的气泡排序法可以利用旗标的方式稍微减少一些比较的时间，当寻访完数组后都没有发生任何的交换动作，表示排序已经完成，而无需再进行之后的循环比较与交换动作，例如：</p>

<p>排序前：    95, 27, 90, 49, 80, 58, 6, 9, 18, 50</p>

<p>第 1 次排序：27 90 49 80 58 6 9 18 50 <strong>95</strong> <br/>
第 2 次排序：27 49 80 58 6 9 18 50 <strong>90</strong> 95 <br/>
第 3 次排序：27 49 58 6 9 18 50 <strong>80</strong> 90 95 <br/>
第 4 次排序：27 49 6 9 18 50 <strong>58</strong> 80 90 95 <br/>
第 5 次排序：27 6 9 18 <strong>49</strong> 50 58 80 90 95 <br/>
第 6 次排序：6 9 18 <strong>27</strong> 49 50 58 80 90 95 <br/>
第 7 次排序：6 9 18 27 49 50 58 80 90 95  &mdash; 没有改变次序,排序完成</p>

<p><strong>Java代码实现：</strong></p>

<pre><code>/*  *
  * 冒泡排序  
  * @param data：等待排序整型数组  
  *     data = { 95, 27, 90, 49, 80, 58, 6, 9, 18, 50 }  
  *    排序结果：  
  *        第 1 次排序：27 90 49 80 58 6 9 18 50 95   
  *        第 2 次排序：27 49 80 58 6 9 18 50 90 95   
  *        第 3 次排序：27 49 58 6 9 18 50 80 90 95   
  *        第 4 次排序：27 49 6 9 18 50 58 80 90 95   
  *        第 5 次排序：27 6 9 18 49 50 58 80 90 95   
  *        第 6 次排序：6 9 18 27 49 50 58 80 90 95   
  *        第 7 次排序：6 9 18 27 49 50 58 80 90 95   
    */   
    public   void  sort( int [] data)  {  
         int  max  =  data.length;  
         boolean  hasChange  =   true ;  
         for  ( int  i  =   0 ; i  &lt;  max  -   1   &amp;&amp;  hasChange; i ++ )  {  
            hasChange  =   false ;  
             for  ( int  j  =   0 ; j  &lt;  max  -  i  -   1 ; j ++ )  {  
                 if  (data[j  +   1 ]  &lt;  data[j])  {  
                     int  temp  =  data[j];  
                    data[j]  =  data[j  +   1 ];  
                    data[j  +   1 ]  =  temp;  
                    hasChange  =   true ;  
                }  
            }  
            System.out.print( "  第   "   +  (i  +   1 )  +   "   次排序：  " );  
             for  ( int  k  =   0 ; k  &lt;=  max  -   1 ; k ++ )  {  
                System.out.print(data[k]  +   "     " );  
            }  
            System.out.println();  
        }  
    }  
</code></pre>
]]></content>
  </entry>
  
</feed>
