<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web开发 | zJun's Tech Blog]]></title>
  <link href="http://zjun.github.io/blog/categories/webkai-fa/atom.xml" rel="self"/>
  <link href="http://zjun.github.io/"/>
  <updated>2014-06-08T00:53:23+08:00</updated>
  <id>http://zjun.github.io/</id>
  <author>
    <name><![CDATA[zJun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dojo在IE中的那些坑]]></title>
    <link href="http://zjun.github.io/blog/2013/05/14/dojo-traps-in-ie/"/>
    <updated>2013-05-14T17:37:00+08:00</updated>
    <id>http://zjun.github.io/blog/2013/05/14/dojo-traps-in-ie</id>
    <content type="html"><![CDATA[<p>最近的一个小项目中使用的<a href="http://dojotoolkit.org/">dojo</a>作为前台页面框架。本来很简单的功能，但是发布给用户做  UAT时却发现一堆简单低级的错误，但在开发环境却始终不能重现，百思不得其解&hellip;原来用户的测试环境是 IE8，果然问题在这，之前测试是在FireFox，没想到相同的功能在IE中却报错。</p>

<!-- more -->


<h3>坑一：</h3>

<ul>
<li>症状：页面上普通按钮，在IE中确实始终会默认submit页面。</li>
<li><p>原因：在<a href="http://zhidao.baidu.com/question/531818487.html">这里</a>找到类似的问题：</p>

<blockquote><p>button元素的默认type属性的值为submit，这个是标准，和IE版本没关系。如果不喜欢可以直接用&lt; input type=&lsquo;button&rsquo;>代替。</p></blockquote></li>
<li><p>解决方案：在 button 强制加上 type=&lsquo;button&rsquo; 属性</p>

<pre><code>  &lt; button data-dojo-type="dijit.form.Button" type='button'&gt;  
     Add  
  &lt; script type="dojo/method" data-dojo-event="onClick" data-dojo-args="evt"&gt;  
     add()  
  &lt; /script&gt;    
  &lt; /button&gt;
</code></pre></li>
</ul>


<h3>坑二：</h3>

<ul>
<li>症状：在datagrid上做了 inline edit后，保存后数据不会刷新，总是更改前的就数据</li>
<li>原因： datagrid的data store默认是使用了cache,这在FireFox中是不会引起问题的，但在IE中就不能刷新数据。</li>
<li>解决方案：在datagrid中不使用缓存：
      var store= new dojo.data.ItemFileWriteStore({
          url : &lsquo;&lt;c:url value=&ldquo;/billitem.wss?method=modifiedListStore&amp;selectId=${selectId}&rdquo; />&rsquo;,
          requestMethod:&ldquo;post&rdquo;,
          urlPreventCache:true}
      );</li>
</ul>


<h3>坑三：</h3>

<ul>
<li>症状：datagrid中最后修改的cell里的值总是不能保存到数据库</li>
<li>原因：datagrid是通过onApplyCellEdit事件将未保存的修改数据save到itemStore.<em>pending(</em>newItem，<em>modifiedItems, </em>removedItems).但是onApplyCellEdit是通过Enter或者blur触发的，在FireFox中当用户点击当前cell以外的任意页面都会触发这个事件，但是在IE中必须要点击datagrid的其他地方才能触发，否则不会（比如：点击grid以外的save按钮）。</li>
<li>解决方案：google了一下午，最后在<a href="http://dojo-toolkit.33424.n3.nabble.com/DataGrid-last-edited-cell-does-not-save-td2358868.html">这里</a>找到解决办法：

<blockquote><p>this is a known problem, I think.  Well at least I&rsquo;ve known about it for
a while lol. I&rsquo;m lazy so I never bothered to check for a bug on it. I
always figured that I could manually trigger lost focus or something on
the cell to get it to set the value to the store.</p></blockquote>

<pre><code>  &lt; table dojoType="dojox.grid.DataGrid" onBlur="onTableBlur"&gt;---&lt; /table&gt;

  function onTableBlur()
  {
    if (this.edit.isEditing())
      this.edit.apply();
  } 
</code></pre></li>
</ul>


<h3>参考资料：</h3>

<ul>
<li><a href="http://dojo-toolkit.33424.n3.nabble.com/DataGrid-last-edited-cell-does-not-save-td2358868.html">DataGrid last edited cell does not save</a></li>
<li><a href="http://stackoverflow.com/questions/12616974/event-not-firing-for-dojos-datagrid">Event not firing for dojo&rsquo;s DataGrid</a></li>
<li><a href="http://zhidao.baidu.com/question/531818487.html">html中button自动提交表单问题!</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HighCharts 笔记2：通过表格生成Pie Chart]]></title>
    <link href="http://zjun.github.io/blog/2013/04/01/highcharts-2-piechart/"/>
    <updated>2013-04-01T15:49:00+08:00</updated>
    <id>http://zjun.github.io/blog/2013/04/01/highcharts-2-piechart</id>
    <content type="html"><![CDATA[<p>接上一篇 <a href="http://zjun.github.com/2013/03/28/highcharts-json-dataformat/">HighCharts笔记之: Bar Chart</a>，这一篇继续记录在项目中使用 Pie Chart 的情况,只是自己的一点总结和记录，以备日后翻阅。这一次是通过页面上的表格(Table)数据，生成对应的饼图（Pie Chart），具体实现如下：</p>

<blockquote><p><strong>Highcharts</strong> 是一个用纯JavaScript编写的一个图表库, 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，并且免费提供给个人学习、个人网站和非商业用途使用。目前HighCharts支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。
HighCharts界面美观，由于使用JavaScript编写，所以不需要像Flash和Java那样需要插件才可以运行，而且运行速度快。另外HighCharts还有很好的兼容性，能够完美支持当前大多数浏览器。</p></blockquote>

<!-- more -->


<h3>Pie Chart</h3>

<p><img src="http://farm9.staticflickr.com/8539/8609442562_2945899e60.jpg" alt="" /></p>

<h3>HTML Code</h3>

<pre><code>&lt;body&gt;

    &lt;div class="modal-header"&gt;
        &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;×&lt;/button&gt;
        &lt;h3 id="myModalLabel"&gt;${title}&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
        &lt;div id="container2" style="width: 100%; height: 280px"&gt;&lt;/div&gt;

        &lt;table id="datatable" class="table table-striped table-bordered table-hover table-condensed"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                     &lt;th&gt;User&lt;/th&gt;
                     &lt;th&gt;${title}&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;c:forEach items="${userSum}" var="item"&gt;
                &lt;tr&gt;
                    &lt;th&gt;${item.user }&lt;/th&gt;
                    &lt;td&gt;${item.sum }&lt;/td&gt;
                &lt;/tr&gt;
                &lt;/c:forEach&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
        &lt;button class="btn" data-dismiss="modal" aria-hidden="true"&gt;Close&lt;/button&gt;
    &lt;/div&gt;

&lt;/body&gt;
</code></pre>

<h3>Javascript Code</h3>

<pre><code>var chart;
Highcharts.visualize = function(table, options) {

    // the data series
    options.series = [];
    var l= options.series.length; 
    options.series[l] = {
      name: '${title}',
      data: []
    };

    $('tbody tr', table).each( function(i) {
        var tr = this;
        var th = $('th', tr).text();
        var td =parseFloat($('td', tr).text());
        options.series[0].data.push({name:th,y:td});
    });
    chart = new Highcharts.Chart(options);
}

// On document ready, call visualize on the datatable.
$(document).ready(function() {         
   var table = document.getElementById('datatable'),
   options = {
         chart: {
            renderTo: 'container2',
            defaultSeriesType: 'pie'
         },
         title: {
            text: '${title}'
         },
         tooltip: {
            formatter: function() {
               return '&lt;b&gt;'+ this.series.name +'&lt;/b&gt;&lt;br/&gt;'+
               this.point.name +' '+ this.y;
            }
         },
         plotOptions: {
             pie: {
                 allowPointSelect: true,
                 cursor: 'pointer'
             }
         }
      };


   Highcharts.visualize(table, options);
});
</code></pre>

<p>这种做法在 Coding 时会更简洁，但在实际运行时效率不高，因为 Pie Chart 需要等待页面上的数据都生成时才能呈现，所以总是给用户一种迟滞感，所以个人感觉还是通过 JSon 的方式生成图表更好（更快）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HighCharts笔记之: Bar Chart]]></title>
    <link href="http://zjun.github.io/blog/2013/03/28/highcharts-json-dataformat/"/>
    <updated>2013-03-28T16:52:00+08:00</updated>
    <id>http://zjun.github.io/blog/2013/03/28/highcharts-json-dataformat</id>
    <content type="html"><![CDATA[<p>最近需要做一些Web图标，研究了几个开源的第三方工具后，最后决定使用<strong>HighCharts</strong>开发：</p>

<p><strong>Highcharts</strong> 是一个用纯JavaScript编写的一个图表库, 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，并且免费提供给个人学习、个人网站和非商业用途使用。目前HighCharts支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。
HighCharts界面美观，由于使用JavaScript编写，所以不需要像Flash和Java那样需要插件才可以运行，而且运行速度快。另外HighCharts还有很好的兼容性，能够完美支持当前大多数浏览器。</p>

<p>HighCharts 可以通过JSON 数据格式与后台交互，从而生成动态的图表。但是在官方的文档中关于 JSON 数据格式的资料很少，经过一下午的调试终于找到了关于柱状图和饼图的数据格式，在这里记录一下，以备后续的查询：</p>

<!-- more -->


<h2>柱状图：</h2>

<p><img src="http://farm9.staticflickr.com/8382/8596618053_22114c25cc_b.jpg" alt="" />
JSON Data</p>

<pre><code>[
    {
        "data":[0,0,0,0,0,0,0,0,9,0,0,1],
        "name":"Actual"
    },
    {
        "data":[1,1,1,4,1,1,1,1,12,1,3,6],
        "name":"Target"
    }
]
</code></pre>

<p>Javascript code</p>

<pre><code>&lt;script type="text/javascript"&gt;
    $(function () {
        var options = {
            chart: {

                renderTo: 'container',
                defaultSeriesType: 'bar'
            },
            title: {
                text: ''
            },
            subtitle: {
                text: ''
            },
            xAxis: {
                categories: ['Activity Entry', 'Activity Update', 'Blog Entry', 'Blog Comments', 'Feed','Bookmark','File','Forum Topic','Forum Reply','Wiki','Ram','Liquid'],
                title: {
                    text: null
                }
            },
            yAxis: {
                min: 0,
                title: {
                    text: 'Units',
                    align: 'high'
                },
                labels: {
                    overflow: 'justify'
                }
            },
            tooltip: {
                formatter: function() {
                    return ''+
                        this.series.name +': '+ this.y;
                }
            },
            plotOptions: {
                bar: {
                    dataLabels: {
                        enabled: true
                    }
                }
            },
            legend: {
                layout: 'vertical',
                align: 'right',
                verticalAlign: 'top',
                x: -100,
                y: 100,
                floating: true,
                borderWidth: 1,
                backgroundColor: '#FFFFFF',
                shadow: true
            },
            credits: {
                enabled: false
            },
            series: []
        };

        $.getJSON('&lt;c:url value="/action.do?method=barChart"/&gt;', function(json) {
                options.series = json;//options.series.push(json);  
                //console.log("JSON: " + JSON.stringify(options));
                //console.log("Render to element with ID : " + options.chart.renderTo);
                //console.log("Number of matching dom elements : " + $("#" + options.chart.renderTo).length);
                new Highcharts.Chart(options);
            }).error(function() {console.log('error');});

        $("a[data-toggle=modal]").click(function(){
            var target = $(this).attr('data-target');
            var url = $(this).attr('href');
            $(target).innerHTML='';
            $(target).load(url);
        });    
    });
&lt;/script&gt;  
</code></pre>

<p>HTML</p>

<pre><code>&lt;div id="container" style="width: 100%; height: 400px"&gt;&lt;/div&gt;
</code></pre>

<p>Java Code &ndash; Action</p>

<pre><code>public ActionForward barChart(ActionMapping mapping, ActionForm form,
            HttpServletRequest request, HttpServletResponse response)
            throws IOException {
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json;charset=utf-8");

        List&lt;Bar&gt; resultList = getBarData();
        JSONArray json = new JSONArray(resultList);
        String result = json.toString();// 转成json数据

        PrintWriter out = response.getWriter();
        out.write(result);
        out.flush();
        out.close();

        return null;
    }

    private List&lt;Bar&gt; getBarData() {
        BlueCommunity target = dao.getLatestTarget();
        BlueCommunity actual = dao.sumLatestActual();

        List&lt;Bar&gt; resultList = new ArrayList&lt;Bar&gt;();
        if (actual != null) {
            resultList.add(new Bar("Actual", actual.getValueArray()));
        } else {
            resultList.add(new Bar("Actual", new int[] { 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0 }));
        }
        resultList.add(new Bar("Target", target.getValueArray()));

        return resultList;
}
</code></pre>

<p>Java Code &ndash; Bar class</p>

<pre><code>public class Bar {

    private static final long serialVersionUID = 6461863786317563773L;

    private String name;
    private int[] data;

    public Bar() {
    };

    public Bar(String name, int[] data) {
        this.name = name;
        this.data = data;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int[] getData() {
        return data;
    }

    public void setData(int[] data) {
        this.data = data;
    }

}
</code></pre>

<p>Java Code &ndash; Community class</p>

<pre><code>public class Community implements Serializable {

    private static final long serialVersionUID = -7516165631503337884L;

    private int id;
    private int version;
    private String remark;
    private int activity_entry;
    private int activity_update;
    private int blog_entry;
    private int blog_comments;
    private int feed;
    private int bookmark;
    private int file;
    private int forum_topic;
    private int forum_reply;
    private int wiki;
    private int iRam;
    private int liquid;
    private int user;

    ...
    getters;
    setters;
    ...

    public int[] getValueArray() {
        int[] array = { activity_entry, activity_update, blog_entry,
                blog_comments, feed, bookmark, file, forum_topic, forum_reply,
                wiki, iRam, liquid };
        return array;
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Forward & Redirect]]></title>
    <link href="http://zjun.github.io/blog/2006/09/19/forward-and-redirect/"/>
    <updated>2006-09-19T18:33:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/09/19/forward-and-redirect</id>
    <content type="html"><![CDATA[<blockquote><p>使用forward的話，網址列上並不會出現被轉發的目標位址，而且forward是在Web應用程式之內進行，可以訪問Web應用程式的隱藏目錄，像是WEB-INF，然而forward只能在Web應用程式中進行，不能指定至其它的Web應用程式位址。</p>

<p>使用redirect的話，是要求客戶端瀏覽器重新發出一個指定的請求位址，因此網址列上會出現被重導的目錄位址，重導的請求是由瀏覽器發出，所以不能訪問Web應用程式中的隱藏目錄，像是WEB-INF，然而重導是重新要求一個網頁，所以可以指定至其它的Web應用程式位址。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSP/Servlet中的事件处理]]></title>
    <link href="http://zjun.github.io/blog/2006/07/20/event-in-jsp-servlet/"/>
    <updated>2006-07-20T14:23:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/20/event-in-jsp-servlet</id>
    <content type="html"><![CDATA[<p>写过AWT或Swing程序的人一定对桌面程序的事件处理机制印象深刻：通过实现Listener接口的类可以在特定事件(Event)发生时，呼叫特定的方法来对事件进行响应。</p>

<p>其实我们在编写JSP/Servle程序时，也有类似的事件处理机制，所不同的是在JSP/Servlet中是在web.xml中注册Listener，由Container在特定事件发生时呼叫特定的实现Listener的类。</p>

<!-- more -->


<h3>1. Servlet中的Listener和Event:</h3>

<p>在JSP 2.0/Servlet 2.4中，共有八个Listener接口，六个Event类别。</p>

<ul>
<li><strong>ServletContextListener接口</strong></li>
</ul>


<p>[<strong>接口方法</strong>] contextInitialized()与 contextDestroyed()</p>

<p>[<strong>接收事件</strong>] ServletContextEvent</p>

<p>[<strong>触发场景</strong>] 在Container加载Web应用程序时（例如启动 Container之后），会呼叫contextInitialized()，而当容器移除Web应用程序时，会呼叫contextDestroyed ()方法。</p>

<ul>
<li><strong>ServletContextAttributeListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] attributeAdded()、 attributeReplaced()、attributeRemoved()</p>

<p>[<strong>接收事件</strong>] ServletContextAttributeEvent</p>

<p>[<strong>触发场景</strong>] 若有对象加入为application（ServletContext）对象的属性，则会呼叫attributeAdded()，同理在置换属性与移除属性时，会分别呼叫attributeReplaced()、attributeRemoved()。</p>

<ul>
<li><strong>HttpSessionListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] sessionCreated()与sessionDestroyed ()</p>

<p>[<strong>接收事件</strong>] HttpSessionEvent</p>

<p>[<strong>触发场景</strong>] 在session （HttpSession）对象建立或被消灭时，会分别呼叫这两个方法。</p>

<ul>
<li><strong>HttpSessionAttributeListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] attributeAdded()、 attributeReplaced()、attributeRemoved()</p>

<p>[<strong>接收事件</strong>] HttpSessionBindingEvent</p>

<p>[<strong>触发场景</strong>] 若有对象加入为session（HttpSession）对象的属性，则会呼叫attributeAdded()，同理在置换属性与移除属性时，会分别呼叫attributeReplaced()、 attributeRemoved()。</p>

<ul>
<li><strong>HttpSessionActivationListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] sessionDidActivate()与 sessionWillPassivate()</p>

<p>[<strong>接收事件</strong>] HttpSessionEvent</p>

<p>[<strong>触发场景</strong>] Activate与Passivate是用于置换对象的动作，当session对象为了资源利用或负载平衡等原因而必须暂时储存至硬盘或其它储存器时（透过对象序列化），所作的动作称之为Passivate，而硬盘或储存器上的session对象重新加载JVM时所采的动作称之为Activate，所以容易理解的，sessionDidActivate()与 sessionWillPassivate()分别于Activeate后与将Passivate前呼叫。</p>

<ul>
<li><strong>ServletRequestListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] requestInitialized()与 requestDestroyed()</p>

<p>[<strong>接收事件</strong>] RequestEvent</p>

<p>[<strong>触发场景</strong>] 在request（HttpServletRequest）对象建立或被消灭时，会分别呼叫这两个方法。</p>

<ul>
<li><strong>ServletRequestAttributeListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] attributeAdded()、 attributeReplaced()、attributeRemoved()</p>

<p>[<strong>接收事件</strong>] HttpSessionBindingEvent</p>

<p>[<strong>触发场景</strong>] 若有对象加入为request（HttpServletRequest）对象的属性，则会呼叫attributeAdded()，同理在置换属性与移除属性时，会分别呼叫attributeReplaced()、 attributeRemoved()。</p>

<ul>
<li><strong>HttpSessionBindingListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] valueBound()与valueUnbound()</p>

<p>[<strong>接收事件</strong>] HttpSessionBindingEvent</p>

<p>[<strong>触发场景</strong>] 实现HttpSessionBindingListener接口的类别，其实例如果被加入至session（HttpSession）对象的属性中，则会呼叫 valueBound()，如果被从session（HttpSession）对象的属性中移除，则会呼叫valueUnbound()，实现HttpSessionBindingListener接口的类别不需在web.xml中设定。</p>

<h3>2. 如何注册Servlet中的事件</h3>

<p>实现上面这几个接口的类别，除了HttpSessionBindingListener外,必须在web.xml中向容器注册，容器才会在对应的事件发生时呼叫对应的类别，如：</p>

<pre><code>&lt; listener &gt;  
&lt; listener-class &gt; demo.servlet.listener.CustomServletContextListener &lt;/ listener-class &gt;  
&lt;/ listener &gt;
</code></pre>

<h3>3. Servlet事件的应用实例</h3>

<p>看到这里,你也许会有疑问: 了解这些 listener和event 有什么用呢?我平时开发没有用到这些,一样也能完成任务啊.</p>

<p>不错,在日常的开发中很少用到这些事件处理的方面,但是在某些情况下使用事件处理机制却可以达到事半功倍的效果,例如下面两个例子:</p>

<p><a href="http://www.blogjava.net/javaora/archive/2005/09/12/12760.html">利用HttpSessionListener实现网站在线人数统计功能</a></p>

<p><a href="http://www.blogjava.net/liuwentao253/archive/2006/11/26/83571.html">使用ServletContextListener在服务器启动和关闭时创建和关闭缓存</a></p>
]]></content>
  </entry>
  
</feed>
