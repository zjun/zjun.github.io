<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | ZJUN NOTE]]></title>
  <link href="http://zjun.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://zjun.github.io/"/>
  <updated>2014-07-27T17:00:58+08:00</updated>
  <id>http://zjun.github.io/</id>
  <author>
    <name><![CDATA[zJun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring MVC 实现 REST service]]></title>
    <link href="http://zjun.github.io/blog/2013/12/04/spring_mvc_rest/"/>
    <updated>2013-12-04T21:06:19+08:00</updated>
    <id>http://zjun.github.io/blog/2013/12/04/spring_mvc_rest</id>
    <content type="html"><![CDATA[<h2>web.xml</h2>

<pre><code>&lt;!-- 配置字符过滤器--&gt;    
&lt;filter&gt;  
    &lt;filter-name&gt;CharacterFilter&lt;/filter-name&gt;  
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  
    &lt;init-param&gt;  
        &lt;param-name&gt;encoding&lt;/param-name&gt;  
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;  
    &lt;/init-param&gt;  
&lt;/filter&gt;  

&lt;filter-mapping&gt;  
    &lt;filter-name&gt;CharacterFilter&lt;/filter-name&gt;  
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
&lt;/filter-mapping&gt;  

&lt;!-- 指定spring配置文件位置 --&gt;  
&lt;context-param&gt;  
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  
    &lt;param-value&gt;  
        &lt;!--加载多个spring配置文件 --&gt;  
        classpath:spring-homebills-cfg.xml
    &lt;/param-value&gt;  
&lt;/context-param&gt;  

&lt;!-- 定义SPRING监听器，加载spring --&gt;  
&lt;listener&gt;  
    &lt;listener-class&gt;  
        org.springframework.web.context.ContextLoaderListener
    &lt;/listener-class&gt;  
&lt;/listener&gt;  

&lt;listener&gt;  
    &lt;listener-class&gt;  
org.springframework.web.context.request.RequestContextListener
    &lt;/listener-class&gt;  
&lt;/listener&gt;   

&lt;servlet&gt;  
    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;  
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  
    &lt;init-param&gt;  
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  
        &lt;param-value&gt;classpath:homebills-servlet.xml&lt;/param-value&gt;  
    &lt;/init-param&gt;  
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  
&lt;/servlet&gt;  

&lt;servlet-mapping&gt;  
    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;  
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  
&lt;/servlet-mapping&gt;  
</code></pre>

<!--more-->


<h2>application-servlet.xml</h2>

<p><div>
  <pre><code class='xml'>&lt;br/&gt;
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&gt;&lt;br/&gt;
&amp;lt;beans  xmlns=&amp;ldquo;&lt;a href=&quot;http://www.springframework.org/schema/beans&quot;&gt;http://www.springframework.org/schema/beans&lt;/a&gt;&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
   xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
   xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.0.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
    http://www.springframework.org/schema/tx
    http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
    &quot;&amp;gt;

&amp;lt;!--
    指定使用注解方式配置,配置自动扫描的包名,
    base-package指定自己应用中控制器所在的包目录
    &amp;lt;context:component-scan/&amp;gt; 扫描指定的包中的类上的注解，常用的注解有： 
    @Controller 声明Action组件
    @Service 声明Service组件
    @Service(&quot;myMovieLister&quot;) 
    @Repository 声明Dao组件
    @Component 泛指组件, 当不好归类时. 
    @RequestMapping(&quot;/menu&quot;) 请求映射 
    @Resource用于注入，( j2ee提供的 ) 默认按名称装配，
    @Resource(name=&quot;beanName&quot;) 
    @Autowired用于注入，(srping提供的) 默认按类型装配 
    @Transactional(rollbackFor={Exception.class}) 事务管理 
    @ResponseBody @Scope(&quot;prototype&quot;)设定bean的作用域
--&amp;gt;
&amp;lt;context:component-scan base-package=&quot;com.zjun.homebills.controller&quot; /&amp;gt;

&amp;lt;!-- 默认的注解映射的支持 --&amp;gt;
&amp;lt;!-- JSR-303 support will be detected on classpath and enabled automatically --&amp;gt;
&amp;lt;mvc:annotation-driven/&amp;gt;

&amp;lt;!-- http://static.springsource.org/spring/docs/3.0.0.RC3/reference/html/ch05s07.html --&amp;gt;&amp;lt;!-- 配置视图解析器 --&amp;gt;
&amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
    &amp;lt;!-- 配置视图层 使用jstl标签 --&amp;gt;
    &amp;lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&amp;gt;
    &amp;lt;!-- 定义视图前缀格式 --&amp;gt;
    &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&amp;gt;
    &amp;lt;!-- 定义视图后缀格式 --&amp;gt;
    &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/beans&gt;&lt;br/&gt;</code></pre>
</div>
</p>

<h2>Controler</h2>

<p><div>
  <pre><code class='java'>package com.zjun.homebills.controller;&lt;/p&gt;

&lt;p&gt;import java.util.List;&lt;/p&gt;

&lt;p&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;br/&gt;
import org.springframework.stereotype.Controller;&lt;br/&gt;
import org.springframework.ui.Model;&lt;br/&gt;
import org.springframework.validation.BindingResult;&lt;br/&gt;
import org.springframework.validation.annotation.Validated;&lt;br/&gt;
import org.springframework.web.bind.annotation.PathVariable;&lt;br/&gt;
import org.springframework.web.bind.annotation.RequestMapping;&lt;br/&gt;
import org.springframework.web.bind.annotation.RequestMethod;&lt;/p&gt;

&lt;p&gt;import com.zjun.homebills.domain.Account;&lt;br/&gt;
import com.zjun.homebills.service.AccountService;&lt;/p&gt;

&lt;p&gt;@Controller&lt;br/&gt;
@RequestMapping(value = &amp;ldquo;/account&amp;rdquo;)&lt;br/&gt;
public class AccountController {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Autowired
AccountService accountService;

/**
 * 
 * 
 * Description: 构建REST风格 /account/list的GET请求时才执行该方法的操作RequestMethod.GET表示
 * 只处理GET请求
 * 
 * @param model
 *            用于上下文参数传递
 * @return 视图页面 account/list 结合user-servlet.xml中配置的视图模型匹配视图页面
 *         实例中方法返回表示/WEB-INF/jsp/account/list.jsp页面
 * 
 */
@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)
public String list(Model model) {
    List&amp;lt;Account&amp;gt; accounts = accountService.getAll();
    model.addAttribute(&quot;accounts&quot;, accounts);
    return &quot;account/list&quot;;
}

@RequestMapping(value = &quot;/add&quot;, method = RequestMethod.GET)
public String add(Model model) {
    model.addAttribute(&quot;account&quot;, new Account()); // 开启ModelDriven
                                                    // 跳转到增加页面时使用该Model
    return &quot;account/add&quot;;
}

/**
 * 
 * Description: 添加操作 请求/account/add form表单提交时使用的post请求调用该方法
 * 
 * @param user
 *            添加的User对象
 * @param br
 *            验证绑定
 * @return 视图页面 添加成功 请求重定向redirect:/account/list 表示执行操作结束后请求定向为/user/users
 *         添加失败 页面转到/WEB-INF/jsp/add.jsp 这里有验证绑定,将在视图页面展示验证错误信息
 * @throws Exception
 * 
 */
@RequestMapping(value = &quot;/add&quot;, method = RequestMethod.POST)
public String add(@Validated Account account, BindingResult br)
        throws Exception {
    // 需要说明的是BindingResult形参一定要跟@Validated修饰的形参后面写验证
    if (br.hasErrors()) { // 如果有错误,直接跳转到添加视图
        return &quot;account/add&quot;; // 服务端跳转 该跳转会自动在前面增加 forward
    }
    accountService.save(account);
    return &quot;redirect:/account/list&quot;; // 客户端跳转 使用 redirect
}

/**
 * 
 * 
 * Description: 预更新操作根据用户名查询用户信息 然后数据交给携带体 展示到视图 REST风格: /更新的用户的用户名/update
 * 
 * @param username
 * @PathVariable修饰 表示形参同URL中的请求参数
 * @param model
 *            携带数据的Model
 * @return 视图页面/WEB-INF/jsp/account/update页面
 * 
 */
@RequestMapping(value = &quot;/{id}/update&quot;, method = RequestMethod.GET)
public String update(@PathVariable Integer id, Model model) {
    System.out.println(&quot;获取到传入的参数值为:&quot; + id);
    Account account = accountService.findById(id);
    model.addAttribute(account);
    return &quot;account/update&quot;;
}

/**
 * 
 * 
 * Description: 真正更新的操作 REST风格： /更新的id/update
 * 
 * @param username
 *            带更新的用户的用户名
 * @param user
 *            带更新的用户的信息对象 @Validated修饰表示信息需要被验证
 * @param br
 *            验证信息绑定对象 必须紧跟在待验证的信息形参后面
 * @return 视图页面 更新成功 请求重定向 /account/list 更新失败 转到/WEB-INF/jsp/account/update.jsp页面
 * 
 */
@RequestMapping(value = &quot;/{id}/update&quot;, method = RequestMethod.POST)
public String update(@PathVariable Integer id, @Validated Account account,
        BindingResult br) {
    if (br.hasErrors()) { // 如果有错误,直接跳转到修改视图
        return &quot;account/update&quot;;
    }
    accountService.update(account);
    return &quot;redirect:/account/list&quot;;
}

/**
 * 
 * 
 * Description: 删除操作 REST风格:/删除的id/delete
 * 
 * @param username
 *            删除的用户名 类似表主键,可以标记到整个记录信息
 * @return 视图页面 请求重定向到 /account/list
 * 
 */
@RequestMapping(value = &quot;/{id}/delete&quot;, method = RequestMethod.GET)
public String delete(@PathVariable Integer id) {
    System.out.println(&quot;获取到传入的参数值为:&quot; + id);
    accountService.deleteById(id);
    return &quot;redirect:/account/list&quot;;
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<h2>JSP</h2>

<p><div>
  <pre><code class='java'>&lt;br/&gt;
&amp;lt;%@ page language=&amp;ldquo;java&amp;rdquo; import=&amp;ldquo;java.util.*&amp;rdquo; pageEncoding=&amp;ldquo;UTF-8&amp;rdquo;%&gt;
&amp;lt;%@ taglib prefix=&amp;ldquo;c&amp;rdquo; uri=&amp;ldquo;&lt;a href=&quot;http://java.sun.com/jsp/jstl/core&quot;&gt;http://java.sun.com/jsp/jstl/core&lt;/a&gt;&amp;rdquo; %&gt;
&amp;lt;%&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String path = request.getContextPath();
String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;%&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;base href=&quot;&amp;lt;%=basePath%&amp;gt;&quot;&amp;gt;
&amp;lt;title&amp;gt;&amp;lt;%=basePath%&amp;gt;&amp;lt;/title&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/head&gt;&lt;/p&gt;

&lt;p&gt;  &lt;body&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h2&amp;gt;账户&amp;lt;/h2&amp;gt;   
&amp;lt;p&amp;gt;&amp;lt;a href=&quot;&amp;lt;%=basePath %&amp;gt;/account/add&quot;&amp;gt;添加账户&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;名称&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;操作&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody&amp;gt;
        &amp;lt;c:forEach items=&quot;${accounts}&quot; var=&quot;account&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;${account.id }&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;${account.name }&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;a href=&quot;&amp;lt;%=basePath %&amp;gt;/account/${account.id }/update&quot;&amp;gt;修改&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;&amp;lt;%=basePath %&amp;gt;/account/${account.id }/delete&quot;&amp;gt;删除&amp;lt;/a&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;/c:forEach&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;/body&gt;&lt;br/&gt;
&lt;/html&gt;&lt;br/&gt;</code></pre>
</div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Spring Data JPA 简化持久层的开发]]></title>
    <link href="http://zjun.github.io/blog/2013/12/03/use_spring_data_jpa/"/>
    <updated>2013-12-03T21:06:19+08:00</updated>
    <id>http://zjun.github.io/blog/2013/12/03/use_spring_data_jpa</id>
    <content type="html"><![CDATA[<p>最近看到<a href="http://www.springside.org.cn/">SpringSide</a>最新版的<a href="https://github.com/springside/springside4/wiki/Design">技术选型</a>中提到了<a href="http://www.springsource.org/spring-data/jpa">Spring Data JPA</a>,号称只需要实现接口就可以实现大部分操作。真有怎么神奇？于是Google一番，果然好使，在这里记录一下：</p>

<!--more-->


<h2>需要的包</h2>

<ul>
<li>spring 3.x(4.0)</li>
<li>spring data jpa 1.4.2</li>
<li>spring data commons 1.5 or later</li>
<li>hibernate 4</li>
<li>JUnit 4.11</li>
<li>log4j 1.2.14</li>
</ul>


<p>所需的包可以在这里下载。</p>

<h2>配置文件</h2>

<h3>persistence.xml</h3>

<p>根据JPA的规范，要在类路径下的META-INF文件夹中创建<strong>persistence.xml</strong>文件，spring提供了<strong>org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean</strong>来进行配置，persistence.xml中的属性都可以在这个bean中进行注入。<br/>
<div>
  <pre><code class='xml'>&lt;br/&gt;
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&gt;&lt;br/&gt;
&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot; version=&quot;2.0&quot;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;persistence-unit name=&quot;appName&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&amp;gt;  
    &amp;lt;provider&amp;gt;org.hibernate.ejb.HibernatePersistence&amp;lt;/provider&amp;gt;  
    &amp;lt;properties&amp;gt;  
        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.connection.url&quot; value=&quot;jdbc:mysql://localhost:3306/appname&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.connection.username&quot; value=&quot;root&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.connection.password&quot; value=&quot;root&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL5Dialect&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;false&quot;/&amp;gt;  
        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&amp;gt;  
    &amp;lt;/properties&amp;gt;  
&amp;lt;/persistence-unit&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/persistence&gt;&lt;br/&gt;</code></pre>
</div>
</p>

<p><strong>说明:</strong> <br/>
1. <strong>persistence-unit</strong>是定义一个单元名称,可以定义多个，在实际使用的时候选择其中一个就可以了。将在后面的<strong>applicationContext.xml</strong>中使用。  <br/>
2. 这里的META-INF是classpath下的目录，不是WEB目录下与WEB-INF同级那个目录，要注意区分，我刚开始的时候就是混淆了这两个目录，搞了很久。</p>

<h3>applicationContext.xml</h3>

<p><div>
  <pre><code class='xml'>&lt;br/&gt;
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&gt;&lt;br/&gt;
&amp;lt;beans xmlns=&amp;ldquo;&lt;a href=&quot;http://www.springframework.org/schema/beans&quot;&gt;http://www.springframework.org/schema/beans&lt;/a&gt;&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;
   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.0.xsd&quot;&amp;gt;  

&amp;lt;context:annotation-config /&amp;gt;      

&amp;lt;context:component-scan base-package=&quot;com.zjun.appname&quot;/&amp;gt;

&amp;lt;!-- 启用 annotation事务--&amp;gt;  
&amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;  

&amp;lt;!-- 配置事务管理器 --&amp;gt;  
&amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&amp;gt;  
    &amp;lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&amp;gt;  
&amp;lt;/bean&amp;gt;  

&amp;lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&amp;gt;  
    &amp;lt;property name=&quot;persistenceUnitName&quot; value=&quot;appName&quot; /&amp;gt;  
    &amp;lt;property name=&quot;persistenceXmlLocation&quot; value=&quot;classpath:META-INF/persistence.xml&quot;/&amp;gt;  
    &amp;lt;property name=&quot;jpaVendorAdapter&quot;&amp;gt;  
        &amp;lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&amp;gt;  
            &amp;lt;property name=&quot;generateDdl&quot; value=&quot;false&quot;/&amp;gt;  
            &amp;lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&amp;gt;  
        &amp;lt;/bean&amp;gt;  
    &amp;lt;/property&amp;gt;  
&amp;lt;/bean&amp;gt;  

&amp;lt;!-- 配置Spring Data JPA扫描目录--&amp;gt;  
&amp;lt;jpa:repositories base-package=&quot;com.zjun.appname.dao&quot;  repository-impl-postfix=&quot;Impl&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot; transaction-manager-ref=&quot;transactionManager&quot;/&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/beans&gt;&lt;/p&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><strong>说明：</strong>主要就是 <code>&lt;jpa:repositories base-package="com.zjun.appname.dao"/&gt;</code>，这个可以扫描repository接口。</p>

<h3>log4j.properties</h3>

<pre><code>log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n

log4j.rootLogger=debug, stdout
log4j.logger.footmark=debug
</code></pre>

<h2>创建 Domain 类</h2>

<p><div>
  <pre><code class='java'>&lt;br/&gt;
@Entity&lt;br/&gt;
@Table(name = &amp;ldquo;account&amp;rdquo;)&lt;br/&gt;
public class Account implements Serializable {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final long serialVersionUID = 1487994788928657645L;  
private int id;  
private String name;  

@Id  
@GeneratedValue(strategy = GenerationType.AUTO)  
public int getId() {  
    return id;  
}  

public void setId(int id) {  
    this.id = id;  
}

@Column(name = &quot;name&quot;)  
public String getName() {  
    return name;  
}  

public void setName(String name) {  
    this.name = name;  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<h2>创建 DAO 类</h2>

<p><div>
  <pre><code class='java'>&lt;br/&gt;
public interface AccountDao extends CrudRepository&amp;lt;Account, Integer&gt; {&lt;/p&gt;

&lt;p&gt;}&lt;br/&gt;</code></pre>
</div>
</p>

<p><strong>说明：</strong><br/>
&ndash; 这里实现的是 <strong>CrudRepository</strong> 接口， 通过这个接口 Spring Data JPA 默认提供了全套的增删改查(CRUD)操作；<br/>
&ndash; 也可以实现 <strong>JpaRepository</strong>接口，通过定义方法名来定制需要的操作；<br/>
&ndash; 泛型中的参数，第一个是Entry类，第二个是这个类ID的类型；
&ndash; 根据规范来对方法进行命名，比如 findByUsername 意思是通过username栏位进行数据查找，具体可以参照下面的表格：</p>

<p><img src="http://farm4.staticflickr.com/3833/11186910614_341d29397c_c.jpg" alt="" /></p>

<h2>Unit Test Case</h2>

<p><div>
  <pre><code class='java'>&lt;br/&gt;
@RunWith(SpringJUnit4ClassRunner.class)&lt;br/&gt;
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TransactionalTestExecutionListener.class })  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@Transactional&lt;br/&gt;
@ContextConfiguration(locations = { &amp;ldquo;classpath:spring-appname-cfg.xml&amp;rdquo; })&lt;br/&gt;
public class TestAccountDao {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ApplicationContext ctx;  
private AccountDao accountDao;  
private Account account;  

@Before  
public void setup() {  
    ctx = new ClassPathXmlApplicationContext(&quot;spring-appname-cfg.xml&quot;);  
    accountDao = ctx.getBean(&quot;accountDao&quot;, AccountDao.class);   
    account = new Account();  
    account.setName(&quot;for testing&quot;);  
}  

@After  
public void clear() {  
    ctx = null;  
}  

@Test  
public void testCRUD() {  
    // Test create  
    Account a = accountDao.save(account);  
    long count = accountDao.count();  
    Assert.assertEquals(1, count);  

    // Test find  
    Account b = accountDao.findOne(a.getId());  
    Assert.assertNotNull(b);  
    Assert.assertEquals(account.getName(), b.getName());  

    // Test update  
    b.setName(&quot;Test Update&quot;);  
    accountDao.save(b);  
    Account c = accountDao.findOne(a.getId());  
    Assert.assertEquals(&quot;Test Update&quot;, c.getName());  

    // Test delete  
    accountDao.delete(account.getId());  
    Account d = accountDao.findOne(account.getId());  
    Assert.assertNull(d);  
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;br/&gt;</code></pre>
</div>
</p>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/">使用 Spring Data JPA 简化 JPA 开发</a></li>
<li><a href="http://mybar.iteye.com/blog/1863390">Spring-data-jpa 使用</a></li>
<li><a href="http://docs.spring.io/spring-data/jpa/docs/1.4.2.RELEASE/reference/html/index.html">Spring Data JPA &ndash; Reference Documentation</a></li>
<li><a href="http://docs.spring.io/spring-data/jpa/docs/1.4.2.RELEASE/reference/html/repository-query-keywords.html">Appendix B. Repository query keywords</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于 Java String 内存管理的几个有趣的例子]]></title>
    <link href="http://zjun.github.io/blog/2013/05/30/java-string-ram-management/"/>
    <updated>2013-05-30T21:06:19+08:00</updated>
    <id>http://zjun.github.io/blog/2013/05/30/java-string-ram-management</id>
    <content type="html"><![CDATA[<p>今天在 <a href="http://www.oschina.net">OSChina</a> 上看到一篇有趣的文章：<a href="http://my.oschina.net/u/551903/blog/134000">关于String内存分配的深入探讨</a>,文章通过几个简单的例子，把Java中String的内存管理的方式解释的很清楚，涨了不少姿势，现根据自己的理解做些笔记在这里：</p>

<!-- more -->


<p>废话不多说，先上代码：</p>

<pre><code>public class StringDemo {

    public static final String MESSAGE = "taobao";

    public static void main(String[] args) {

        // ---------------------------------------------
        String a = "tao" + "bao";
        String b = "tao";
        String c = "bao";

        System.out.println(a == MESSAGE);// true
        System.out.println((b + c) == MESSAGE);// false

        // ---------------------------------------------
        final String d = "tao";
        final String e = "bao";

        System.out.println((d + e) == MESSAGE);// true

        // ---------------------------------------------
        String f = "tao" + "bao";
        String g = new String("taobao");

        System.out.println(f == MESSAGE); // true
        System.out.println(g == MESSAGE); // false

        g = g.intern();

        System.out.println(g == MESSAGE); // true
        System.out.println(f == g.intern()); // true
        // ---------------------------------------------
    }
}
</code></pre>

<h2>笔记：</h2>

<ul>
<li>Java中对于编译和运行时能够知道大小的变量（如：引用变量和基本类型的值）存放于<strong>栈内存</strong></li>
<li>Java中通过 new 产生的变量和大小会在运行时变化的变量(如：数组和链表)存放于<strong>堆内存，但指向对象的引用还是存放在栈内存</strong></li>
<li><strong>栈内存中的数据会相互共享</strong>，如果新增变量的值在栈中已经存在，那么新变量将指向同一个地址和值，而不会新增一个空间来存放自己的值;如果没有就在该栈内存增加一个该常量，并将变量指向该常量。</li>
<li>对于<strong>直接赋值的字符串常量</strong>（如String s=“Hello World”；中的Hello World）也是<strong>存放在栈内存中</strong></li>
<li>堆内存没有数据共享的特点,每次都会新增划分一个空间给新的变量，哪怕是相同的值</li>
<li>Java <strong>编译器的优化</strong>，会对于<strong>字符串常量的相加</strong>，在编译时<strong>直接</strong>将字符串<strong>合并</strong>，而不是等到运行时再合并，比如：<strong>String a = &ldquo;tao&rdquo;+&ldquo;bao&rdquo;;和String a = &ldquo;taobao&rdquo;;编译出的字节码是一样的</strong></li>
<li><strong>Java对String的相加是通过StringBuffer实现的</strong>，先构造一个StringBuffer,然后调用append()方法追加，然后将StringBuffer转化成String对象。StringBuffer对象<strong>在堆内存中</strong>，那转换成的String对象理所应当的也是在堆内存中</li>
<li><strong>intern()</strong>方法会<strong>先检查</strong>String池(或者说成<strong>栈内存</strong>)中是否存在相同的字符串常量，如果有就返回</li>
<li><strong>final变量</strong>不可能再次赋值了，所以存放在<strong>栈内存里</strong></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java并发编程笔记：线程管理]]></title>
    <link href="http://zjun.github.io/blog/2012/05/02/java_concurrency_note_basic_manage_threads/"/>
    <updated>2012-05-02T16:52:00+08:00</updated>
    <id>http://zjun.github.io/blog/2012/05/02/java_concurrency_note_basic_manage_threads</id>
    <content type="html"><![CDATA[<h2>创建线程</h2>

<p>两种方法：<br/>
1. 通过直接继承thread类，然后覆盖run()方法;
2. 构建一个实现Runnable接口的类, 然后创建一个thread类对象并传递Runnable对象作为构造参数;</p>

<p><strong>启动线程：</strong><br/>
只有调用start()方法才能启动一个新的执行线程。</p>

<h2>线程的属性</h2>

<p>通过以下方法访问线程属性：<br/>
1. id:          <code>thread.getId()</code><br/>
2. name:        <code>thread.getName()</code><br/>
3. Priority:    <code>thread.getPriority()</code><br/>
4. State:       <code>thread.getState()</code></p>

<h2>中断线程</h2>

<ol>
<li>在线程外调用线程的 <code>interrupt()</code> 方法；</li>
<li>在线程内判断 <code>isInterrupted()</code>，如果为true 则退出线程；</li>
<li>可以在线程内判断 <code>isInterrupted()</code>， 如果为true 则抛出 <code>InterruptedException</code> 异常来进行中断处理；</li>
</ol>


<p><strong>说明</strong>： Thread 类有一个boolean类型的属性来表明线程是否被中断。当你调用线程的 <code>interrupt()</code> 方法，就代表你把这个属性设置为 true。 而 <code>isInterrupted()</code> 方法仅返回属性值。</p>

<h2>线程的睡眠和恢复</h2>

<ol>
<li>可以使用 <code>Thread.sleep()</code> 方法休眠线程，此方法接收一个整数作为参数，表示线程暂停运行的毫秒数；</li>
<li>也可以使用一个有TimeUnit列举元素的sleep() 方法，使用线程类的 sleep() 方法让当前线程睡眠，它接收的参数单位是表示并转换成毫秒的: <code>TimeUnit.SECONDS.sleep(1);</code>  ；</li>
<li>可以通过 <code>thread.interrupt();</code> 中断休眠，唤醒线程；</li>
</ol>


<p><strong>说明</strong>：当调用sleep()方法， Thread 离开CPU并在一段时间内停止运行。在这段时间内，它是不消耗CPU时间的，使用可以执行其他任务。</p>

<h2>等待线程终结</h2>

<p>当前线程调用其他线程的 join() 后， 会暂停当前线程，直到被调用线程执行完成。</p>

<p>Java 提供2种形式的 join() 方法:<br/>
1. <code>join (long milliseconds)</code><br/>
2. <code>join (long milliseconds, long nanos)</code></p>

<p>第一种 join() 方法, 这方法让调用线程等待特定的毫秒数。例如，如果thread1对象使用代码 thread2.join(1000), 那么线程 thread1暂停运行，直到以下其中一个条件发生：</p>

<ol>
<li>thread2 结束运行</li>
<li>1000 毫秒过去了</li>
</ol>


<p>当其中一个条件为真时，join() 方法返回。</p>

<p>第二个版本的 join() 方法和第一个很像，只不过它接收一个毫秒数和一个纳秒数作为参数。</p>

<h2>守护线程</h2>

<p><strong>守护线程</strong>: 这种线程的优先级非常低，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM会结束守护线程并终止程序。</p>

<ol>
<li><code>setDaemon(true);</code> 设置守护线程</li>
<li>只能在 <code>start()</code> 方法之前可以调用 <code>setDaemon()</code> 方法。一旦线程运行了，就不能修改守护状态</li>
<li>可以使用 <code>isDaemon()</code> 方法来检查线程是否是守护线程（方法返回 true) 或者是使用者线程 (方法返回 false)</li>
</ol>


<h2>处理线程中的 Unchecked exceptions</h2>

<p>Java里有2种异常:</p>

<ul>
<li><p>检查异常（<strong>Checked exceptions</strong>）: 这些异常必须强制捕获它们或在一个方法里的throws子句中。 例如， <code>IOException</code> 或者<code>ClassNotFoundException</code></p></li>
<li><p>未检查异常（<strong>Unchecked exceptions</strong>）: 这些异常不用强制捕获它们。例如:<code>NumberFormatException</code></p></li>
<li><p>thread.run() 方法不接受 throws 子句。当一个非检查异常被抛出，默认的行为是在控制台写下stack trace并退出程序。</p></li>
<li>实现 UncaughtExceptionHandler 接口并实现 uncaughtException() 方法;</li>
<li>thread.setUncaughtExceptionHandler(new ExceptionHandler());</li>
</ul>


<p><div>
  <pre><code class='java'>&lt;br/&gt;
public class ExceptionHandler implements UncaughtExceptionHandler{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void uncaughtException(Thread t, Throwable e){  
    System.out.printf(&quot;An exception has been captured\n&quot;);  
    System.out.printf(&quot;Thread: %s\n&quot;,t.getId());  
    System.out.printf(&quot;Exception: %s: %s\n&quot;,e.getClass().getName(),e.getMessage());  
    System.out.printf(&quot;Stack Trace: \n&quot;);  
    e.printStackTrace(System.out); System.out.printf(&quot;Thread status: %s\n&quot;,t.getState());  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p><div>
  <pre><code class='java'>&lt;br/&gt;
Thread thread=new Thread(task);&lt;br/&gt;
thread.setUncaughtExceptionHandler(new ExceptionHandler());&lt;br/&gt;
thread.start();&lt;br/&gt;</code></pre>
</div>
</p>

<h2>本地线程变量</h2>

<ol>
<li>本地线程变量 ThreadLocal;</li>
<li>本地线程变量为每个使用这些变量的线程储存属性值;</li>
<li>使用 get() 方法读取值和使用 set() 方法改变值;</li>
<li>如果第一次访问本地线程变量的值，没有值给当前的线程对象，那么本地线程变量会调用 initialValue() 方法来设置值给线程并返回初始值;</li>
<li>本地线程类还提供 remove() 方法，删除存储在线程本地变量里的值;</li>
</ol>


<h2>线程组</h2>

<ol>
<li>创建线程组： ThreadGroup threadGroup = new ThreadGroup(&ldquo;Searcher&rdquo;);</li>
<li>加入线程组： Thread thread=new Thread(threadGroup, runnable );</li>
<li>threadGroup.list() 得到关于 ThreadGroup ob对象信息；</li>
<li>activeCount() 方法获取线程个数；</li>
<li>enumerate() 方法获取与ThreadGroup对象关联的线程的列表；
threadGroup.enumerate(Thread[]);</li>
<li>interrupt() 方法中断组里的其他线程： threadGroup.interrupt();</li>
</ol>


<h2>处理线程组中的 Unchecked exceptions</h2>

<ol>
<li>override ThreadGroup 的 uncaughtException() 方法；</li>
<li>当一个非捕捉异常在线程内抛出，JVM会为这个异常寻找3种可能handlers：<br/>
1). 找这个未捕捉的线程对象的异常handle;<br/>
2). 在线程对象的ThreadGroup里寻找非捕捉异常的handler;<br/>
3) 寻找默认非捕捉异常handle;</li>
</ol>


<p>如果没有 handlers存在, 那么 JVM会把异常的 stack trace 写入控制台并结束任务。</p>

<h2>线程工厂</h2>

<ol>
<li>ThreadFactory 接口;</li>
<li>实现接口方法: newThread(), 接收 Runnable 对象作为参数并返回一个 Thread 对象;</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剔除List中的重复值]]></title>
    <link href="http://zjun.github.io/blog/2007/01/18/remove-duplicate-items-in-array/"/>
    <updated>2007-01-18T13:48:00+08:00</updated>
    <id>http://zjun.github.io/blog/2007/01/18/remove-duplicate-items-in-array</id>
    <content type="html"><![CDATA[<h3>方法一：循环元素删除</h3>

<pre><code>//  删除ArrayList中重复元素
public   static   void  removeDuplicate(List list)  {
   for  ( int  i  =   0 ; i  &lt;  list.size()  -   1 ; i ++ )  {
    for  ( int  j  =  list.size()  -   1 ; j  &gt;  i; j -- )  {
      if  (list.get(j).equals(list.get(i)))  {
        list.remove(j);
      }
    }
  }
  System.out.println(list);
}
</code></pre>

<!-- more -->


<h3>方法二：通过HashSet剔除</h3>

<pre><code>//  删除ArrayList中重复元素
public   static   void  removeDuplicate(List list)  {
    HashSet h  =   new  HashSet(list);
    list.clear();
    list.addAll(h);
    System.out.println(list);
}
</code></pre>

<h3>方法三： 删除ArrayList中重复元素，保持顺序</h3>

<pre><code>// 删除ArrayList中重复元素，保持顺序
public   static   void  removeDuplicateWithOrder(List list)  {
      Set set  =   new  HashSet();
      List newList  =   new  ArrayList();
   for  (Iterator iter  =  list.iterator(); iter.hasNext();)  {
         Object element  =  iter.next();
         if  (set.add(element))
            newList.add(element);
     }
     list.clear();
     list.addAll(newList);
     System.out.println( " remove duplicate "   +  list);
 }
</code></pre>
]]></content>
  </entry>
  
</feed>
