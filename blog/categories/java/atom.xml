<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | zJun's Tech Blog]]></title>
  <link href="http://zjun.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://zjun.github.io/"/>
  <updated>2014-06-08T00:53:23+08:00</updated>
  <id>http://zjun.github.io/</id>
  <author>
    <name><![CDATA[zJun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于 Java String 内存管理的几个有趣的例子]]></title>
    <link href="http://zjun.github.io/blog/2013/05/30/java-string-ram-management/"/>
    <updated>2013-05-30T21:06:19+08:00</updated>
    <id>http://zjun.github.io/blog/2013/05/30/java-string-ram-management</id>
    <content type="html"><![CDATA[<p>今天在 <a href="http://www.oschina.net">OSChina</a> 上看到一篇有趣的文章：<a href="http://my.oschina.net/u/551903/blog/134000">关于String内存分配的深入探讨</a>,文章通过几个简单的例子，把Java中String的内存管理的方式解释的很清楚，涨了不少姿势，现根据自己的理解做些笔记在这里：</p>

<!-- more -->


<p>废话不多说，先上代码：</p>

<pre><code>public class StringDemo {

    public static final String MESSAGE = "taobao";

    public static void main(String[] args) {

        // ---------------------------------------------
        String a = "tao" + "bao";
        String b = "tao";
        String c = "bao";

        System.out.println(a == MESSAGE);// true
        System.out.println((b + c) == MESSAGE);// false

        // ---------------------------------------------
        final String d = "tao";
        final String e = "bao";

        System.out.println((d + e) == MESSAGE);// true

        // ---------------------------------------------
        String f = "tao" + "bao";
        String g = new String("taobao");

        System.out.println(f == MESSAGE); // true
        System.out.println(g == MESSAGE); // false

        g = g.intern();

        System.out.println(g == MESSAGE); // true
        System.out.println(f == g.intern()); // true
        // ---------------------------------------------
    }
}
</code></pre>

<h2>笔记：</h2>

<ul>
<li>Java中对于编译和运行时能够知道大小的变量（如：引用变量和基本类型的值）存放于<strong>栈内存</strong></li>
<li>Java中通过 new 产生的变量和大小会在运行时变化的变量(如：数组和链表)存放于<strong>堆内存，但指向对象的引用还是存放在栈内存</strong></li>
<li><strong>栈内存中的数据会相互共享</strong>，如果新增变量的值在栈中已经存在，那么新变量将指向同一个地址和值，而不会新增一个空间来存放自己的值;如果没有就在该栈内存增加一个该常量，并将变量指向该常量。</li>
<li>对于<strong>直接赋值的字符串常量</strong>（如String s=“Hello World”；中的Hello World）也是<strong>存放在栈内存中</strong></li>
<li>堆内存没有数据共享的特点,每次都会新增划分一个空间给新的变量，哪怕是相同的值</li>
<li>Java <strong>编译器的优化</strong>，会对于<strong>字符串常量的相加</strong>，在编译时<strong>直接</strong>将字符串<strong>合并</strong>，而不是等到运行时再合并，比如：<strong>String a = &ldquo;tao&rdquo;+&ldquo;bao&rdquo;;和String a = &ldquo;taobao&rdquo;;编译出的字节码是一样的</strong></li>
<li><strong>Java对String的相加是通过StringBuffer实现的</strong>，先构造一个StringBuffer,然后调用append()方法追加，然后将StringBuffer转化成String对象。StringBuffer对象<strong>在堆内存中</strong>，那转换成的String对象理所应当的也是在堆内存中</li>
<li><strong>intern()</strong>方法会<strong>先检查</strong>String池(或者说成<strong>栈内存</strong>)中是否存在相同的字符串常量，如果有就返回</li>
<li><strong>final变量</strong>不可能再次赋值了，所以存放在<strong>栈内存里</strong></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剔除List中的重复值]]></title>
    <link href="http://zjun.github.io/blog/2007/01/18/remove-duplicate-items-in-array/"/>
    <updated>2007-01-18T13:48:00+08:00</updated>
    <id>http://zjun.github.io/blog/2007/01/18/remove-duplicate-items-in-array</id>
    <content type="html"><![CDATA[<h3>方法一：循环元素删除</h3>

<pre><code>//  删除ArrayList中重复元素
public   static   void  removeDuplicate(List list)  {
   for  ( int  i  =   0 ; i  &lt;  list.size()  -   1 ; i ++ )  {
    for  ( int  j  =  list.size()  -   1 ; j  &gt;  i; j -- )  {
      if  (list.get(j).equals(list.get(i)))  {
        list.remove(j);
      }
    }
  }
  System.out.println(list);
}
</code></pre>

<!-- more -->


<h3>方法二：通过HashSet剔除</h3>

<pre><code>//  删除ArrayList中重复元素
public   static   void  removeDuplicate(List list)  {
    HashSet h  =   new  HashSet(list);
    list.clear();
    list.addAll(h);
    System.out.println(list);
}
</code></pre>

<h3>方法三： 删除ArrayList中重复元素，保持顺序</h3>

<pre><code>// 删除ArrayList中重复元素，保持顺序
public   static   void  removeDuplicateWithOrder(List list)  {
      Set set  =   new  HashSet();
      List newList  =   new  ArrayList();
   for  (Iterator iter  =  list.iterator(); iter.hasNext();)  {
         Object element  =  iter.next();
         if  (set.add(element))
            newList.add(element);
     }
     list.clear();
     list.addAll(newList);
     System.out.println( " remove duplicate "   +  list);
 }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 LRUMap]]></title>
    <link href="http://zjun.github.io/blog/2006/07/31/use-lrumap/"/>
    <updated>2006-07-31T14:52:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/31/use-lrumap</id>
    <content type="html"><![CDATA[<p>使用过开源缓存包(如:<a href="http://ehcache.sourceforge.net/">EHCache</a>)都知道，缓存策略中主要分为FIFO,LRU,LFU等几种。而Jakarta Commons中提供的 <strong>org.apache.commons.collections.map.LRUMap</strong> 可用来保存最近使用的几条记录，提供了<strong>LRU(Least Recently Used)</strong>缓存策略的实现。</p>

<p>具体使用方法如下:</p>

<!-- more -->


<pre><code>import  java.util.Map;
import  org.apache.commons.collections.map.LRUMap;

LRUMap cache  =   new  LRUMap( 5  );     

//  Populate the cache with 5 stock prices
cache.put(  " MSFT " ,  new  Float(  0.03  ) );
cache.put(  " TSC " ,  new  Float(  0.001  ) );
cache.put(  " LU " ,  new  Float(  23.30  ) );
cache.put(  " CSCO " ,  new  Float(  242.20  ) );
cache.put(  " P " ,  new  Float(  10.23  ) );

//  Now use some of the entries in the cache
Float cscoPrice   =  (Float) cache.get(  " CSCO "  );
Float msPrice  =  (Float) cache.get(  " MSFT "  );
Float tscPrice  =  (Float) cache.get(  " TSC "  );
Float luPrice  =  (Float) cache.get(  " LU "  );
Float pPrice  =  (Float) cache.get(  " P "  );
Float msPrice2  =  (Float) cache.get(  " MSFT "  );

//  Add another price to the Map, this should kick out the LRU item.
cache.put(  " AA " ,  new  Float(  203.20  ) );
</code></pre>

<p>此时,缓存中的元素为:</p>

<blockquote><p>[CSCO]<br/>
[MSFT]<br/>
[TSC]<br/>
[LU]<br/>
[P]<br/>
[AA]</p></blockquote>

<p>由于LRU最近没有被访问,所以当AA加入时,由于超过了缓存的最大容量(5),所以被剔除了缓存.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 StringUtils 工具类]]></title>
    <link href="http://zjun.github.io/blog/2006/07/27/using-stringutils/"/>
    <updated>2006-07-27T16:01:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/27/using-stringutils</id>
    <content type="html"><![CDATA[<p>org.apache.commons.lang.StringUtils中提供许多有用的字符串操作方法，了解这些方法，我们可以避免许多不必要的重复工作。下面介绍其中比较有用的几个方法：</p>

<!-- more -->


<p><strong>检查空字符串：</strong></p>

<pre><code>StringUtils.isBlank(String str);  
StringUtils.isNotBlank(String str);
</code></pre>

<p><strong>缩写字符串：</strong></p>

<pre><code>String test  =   " This is a test of the abbreviation. ";  
System.out.println( StringUtils.abbreviate( test,  10  ) );
</code></pre>

<p>[<strong>Console输出</strong>]</p>

<blockquote><p>This is&hellip;</p></blockquote>

<p><strong>查找嵌套字符串：</strong></p>

<pre><code>String htmlContent  =   " &lt;html&gt;\n "   +  
                      "   &lt;head&gt;\n "   +  
                      "     &lt;title&gt;Test Page&lt;/title&gt;\n "   +  
                      "   &lt;/head&gt;\n "   +  
                      "   &lt;body&gt;\n "   +  
                      "     &lt;p&gt;This is a TEST!&lt;/p&gt;\n "   +  
                      "   &lt;/body&gt;\n "   +  
                      " &lt;/html&gt; " ;  

//  Extract the title from this XHTML content   
String title  =  StringUtils.substringBetween(htmlContent,  " &lt;title&gt; " ,  " &lt;/title&gt; " );
System.out.println(  " Title:  "   +  title );
</code></pre>

<p>[<strong>Console输出</strong>]</p>

<blockquote><p>Title: Test Page</p></blockquote>

<p><strong>验证字符串：</strong></p>

<pre><code>String test1  =   " ORANGE " ;  
String test2  =   " ICE9 " ;  
String test3  =   " ICE CREAM " ;  
String test4  =   " 820B Judson Avenue " ;  
boolean  t1val  =  StringUtils.isAlpha( test1 );  //  returns true  
boolean  t2val  =  StringUtils.isAlphanumeric( test2 );  //  returns true   
boolean  t3val  =  StringUtils.isAlphaSpace( test3 );  //  returns true  
boolean  t4val  =  StringUtils.isAlphanumericSpace( test4 );  //  returns true  
</code></pre>

<p><strong>计算字符串出现频率：</strong></p>

<pre><code>File manuscriptFile  =   new  File( " manuscript.txt " );  
Reader reader  =   new  FileReader( manuscriptFile );  
StringWriter stringWriter  =   new  StringWriter( );  
while ( reader.ready( ) )  { writer.write( reader.read( ) ); }  
String manuscript  =  stringWriter.toString( );  
//  Convert string to lowercase  
manuscript  =  StringUtils.lowerCase(manuscript);  
//  count the occurrences of "futility"  
int  numFutility  =  StringUtils.countMatches( manuscript,  " futility "  );   
</code></pre>

<p><strong>比较不同字符串：</strong></p>

<pre><code>int  dist  =  StringUtils.getLevenshteinDistance(  " Word " ,  " World "  );  
String diff  =  StringUtils.difference(  " Word " ,  " World "  );  
int  index  =  StringUtils.indexOfDifference(  " Word " ,  " World "  );  
System.out.println(  " Edit Distance:  "   +  dist );  
System.out.println(  " Difference:  "   +  diff );  
System.out.println(  " Diff Index:  "   +  index );  
</code></pre>

<p>[<strong>Console输出</strong>]</p>

<blockquote><p>Edit Distance:  2<br/>
Difference: ld<br/>
Diff Index:  3</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[java生成UUID]]></title>
    <link href="http://zjun.github.io/blog/2006/07/12/java-generate-uuid/"/>
    <updated>2006-07-12T14:52:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/12/java-generate-uuid</id>
    <content type="html"><![CDATA[<p><strong>UUID</strong>(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得），UUID的唯一缺陷在于生成的结果串会比较长。</p>

<p>在Java中生成UUID主要有以下几种方式:</p>

<!-- more -->


<h3>1. JDK1.5</h3>

<p>如果使用的JDK1.5的话,那么生成UUID变成了一件简单的事,以为JDK实现了UUID: java.util.UUID,直接调用即可.</p>

<pre><code>UUID uuid  =  UUID.randomUUID();
</code></pre>

<h3>2. 第三方开源类库(推荐使用):</h3>

<p>最著名的是 <a href="http://jug.safehaus.org/">JUG</a> .特点上是: 纯Java实现，开源，LGPL协议。采用了Native的方式产生真正的Uuid.而且提供了不同平台的实现,包括:</p>

<ul>
<li>Linux / x86</li>
<li>Windows (98, ME, NT, 2K, XP?) / x86</li>
<li>Solaris / Sparc</li>
<li>Mac OS X</li>
<li><p>FreeBSD / x86</p>

<p>  import  org.doomdark.uuid.UUID;
  import  org.doomdark.uuid.UUIDGenerator;</p>

<p>  UUIDGenerator generator  =  UUIDGenerator.getInstance();
  UUID uuid  =  generator.generateRandomBasedUUID();</p></li>
</ul>


<h3>3. Java代码实现:</h3>

<p>如果你使用JDK1.4或以前版本,又不想加入第三方的类库的话,下面提供了一个纯Java的UUID实现. 不过需要注意的是:<strong>这里产生的可能不是真正的UUID，只不过重复的机会少一些而已</strong>。</p>

<pre><code>import  java.net.InetAddress;
import  java.net.UnknownHostException;

/**
 * UUID（Univeral Unique Identity）类
 * 


 * Title: 生成唯一编码
 * 

 * 


 * Description: 源自于w3c.org &lt;&lt;/font&gt;
http://源自于w3c.org &gt;
 * 
 * 


 * Copyright: Copyright (c) 2001-2004
 * 

 * 
 *  @version  1.0
  */
public   final   class  UUID  {

     /**
     *  @serial  Integer that helps create a unique UID.
      */
     private   int  unique;

     /**
     *  @serial  Long used to record the time. The time will be
     *         used to create a unique UID.
      */
     private   long  time;

     /**
     * InetAddress to make the UID globally unique
      */
     private   static  String address;

     /**
     * a random number
      */
     private   static   int  hostUnique;

     /**
     * Used for synchronization
      */
     private   static  Object mutex;

     private   static   long  lastTime;

     private   static   long  DELAY;

     private   static  String generateNoNetworkID()  {
        Thread current  =  Thread.currentThread();
        String nid  =  current.activeCount()  +  System.getProperty( " os.version " )
                 +  System.getProperty( " user.name  " )
                 +  System.getProperty( " java.version " );
        System.out.println( " netWorkId = "   +  nid);
        MD5 md5  =   new  MD5(nid);
        md5.processString();
         return  md5.getStringDigest();
    }

     static   {
        hostUnique  =  ( new  Object()).hashCode();
        mutex  =   new  Object();
        lastTime  =  System.currentTimeMillis();
        DELAY  =   10 ;  //  in milliseconds
         try   {
            String s  =  InetAddress.getLocalHost().getHostAddress();
            MD5 md5  =   new  MD5(s);
            md5.processString();
            address  =  md5.getStringDigest();
        }   catch  (UnknownHostException ex)  {
            address  =  generateNoNetworkID();
        }
    }

     public  UUID()  {
         synchronized  (mutex)  {
             boolean  done  =   false ;
             while  ( ! done)  {
                time  =  System.currentTimeMillis();
                 if  (time   lastTime  +  DELAY)  {
                     //  pause for a second to wait for time to change
                     try   {
                        Thread.currentThread().sleep(DELAY);
                    }   catch  (java.lang.InterruptedException e)  {
                    }   //  ignore exception
                     continue ;
                }   else   {
                    lastTime  =  time;
                    done  =   true ;
                }
            }
            unique  =  hostUnique;
        }
    }

     public  String toString()  {
         return  Integer.toString(unique,  16 )  +  Long.toString(time,  16 )  +  address;
    }

     public   boolean  equals(Object obj)  {
         if  ((obj  !=   null )  &amp;&amp;  (obj  instanceof  UUID))  {
            UUID uuid  =  (UUID) obj;
             return  (unique  ==  uuid.unique  &amp;&amp;  time  ==  uuid.time  &amp;&amp;  address
                    .equals(uuid.address));
        }   else   {
             return   false ;
        }
    }

     public   static   void  main(String args[])  {
        System.out.println( new  UUID());
        System.out.println( new  UUID());
        System.out.println( new  UUID());
         long  start  =  System.currentTimeMillis();
        System.out.println( new  UUID());
         long  end  =  System.currentTimeMillis();
        System.out.println((end  -  start));
        System.out.println( new  UUID().toString().length());
    }

     /**
     * 返回最新的UUID号码
     * 
     *  @return  String UUID，长50位
     * 
      */
     public   final   static  String getUUID()  {
        UUID uid  =   new  UUID();
         return  uid.toString();
    }
}
</code></pre>

<p>其中使用到<strong>MD5加密算法</strong>,实现代码如下:</p>

<pre><code>import  java.io.ByteArrayInputStream;
import  java.io.File;
import  java.io.FileInputStream;
import  java.io.IOException;
import  java.io.InputStream;
import  java.io.UnsupportedEncodingException;

/**
 * MD5 加密算法类
 * 
 * 


 * Description: 源自于w3c.org &lt;&lt;/font&gt;
http://源自于w3c.org &gt;
 * 
 * 


 * Copyright: Copyright (c) 2001-2004
 * 

 * 
 *  @version  1.0
  */
public   class  MD5  {
     private   static   final   int  BUFFER_SIZE  =   1024 ;

     private   static   final   int  S11  =   7 ;

     private   static   final   int  S12  =   12 ;

     private   static   final   int  S13  =   17 ;

     private   static   final   int  S14  =   22 ;

     private   static   final   int  S21  =   5 ;

     private   static   final   int  S22  =   9 ;

     private   static   final   int  S23  =   14 ;

     private   static   final   int  S24  =   20 ;

     private   static   final   int  S31  =   4 ;

     private   static   final   int  S32  =   11 ;

     private   static   final   int  S33  =   16 ;

     private   static   final   int  S34  =   23 ;

     private   static   final   int  S41  =   6 ;

     private   static   final   int  S42  =   10 ;

     private   static   final   int  S43  =   15 ;

     private   static   final   int  S44  =   21 ;

     private   static   byte  padding[]  =   { ( byte )  0x80 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 , ( byte )  0 ,
            ( byte )  0  } ;

     private  InputStream in  =   null ;

     private   boolean  stringp  =   false ;

     private   int  state[]  =   null ;

     private   long  count  =   0 ;

     private   byte  buffer[]  =   null ;

     private   byte  digest[]  =   null ;

     private   static  String stringify( byte  buf[])  {
        StringBuffer sb  =   new  StringBuffer( 2   *  buf.length);
         for  ( int  i  =   0 ; i   buf.length; i ++ )  {
             int  h  =  (buf[i]  &amp;   0xf0 )  &gt;&gt;   4 ;
             int  l  =  (buf[i]  &amp;   0x0f );
            sb.append( new  Character(( char ) ((h  &gt;   9 )  ?   ' a '   +  h  -   10  :  ' 0 '   +  h)));
            sb.append( new  Character(( char ) ((l  &gt;   9 )  ?   ' a '   +  l  -   10  :  ' 0 '   +  l)));
        }
         return  sb.toString();
    }

     private   final   int  F( int  x,  int  y,  int  z)  {
         return  ((x  &amp;  y)  |  (( ~ x)  &amp;  z));
    }

     private   final   int  G( int  x,  int  y,  int  z)  {
         return  ((x  &amp;  z)  |  (y  &amp;  ( ~ z)));
    }

     private   final   int  H( int  x,  int  y,  int  z)  {
         return  (x  ^  y  ^  z);
    }

     private   final   int  I( int  x,  int  y,  int  z)  {
         return  (y  ^  (x  |  ( ~ z)));
    }

     private   final   int  rotate_left( int  x,  int  n)  {
         return  ((x  &lt;&lt;&lt;/span&gt;  n) | (x &gt;&gt;&gt; (32 -  n)));
    }

     private   final   int  FF( int  a,  int  b,  int  c,  int  d,  int  x,  int  s,  int  ac)  {
        a  +=  (F(b, c, d)  +  x  +  ac);
        a  =  rotate_left(a, s);
        a  +=  b;
         return  a;
    }

     private   final   int  GG( int  a,  int  b,  int  c,  int  d,  int  x,  int  s,  int  ac)  {
        a  +=  (G(b, c, d)  +  x  +  ac);
        a  =  rotate_left(a, s);
        a  +=  b;
         return  a;
    }

     private   final   int  HH( int  a,  int  b,  int  c,  int  d,  int  x,  int  s,  int  ac)  {
        a  +=  (H(b, c, d)  +  x  +  ac);
        a  =  rotate_left(a, s);
        a  +=  b;
         return  a;
    }

     private   final   int  II( int  a,  int  b,  int  c,  int  d,  int  x,  int  s,  int  ac)  {
        a  +=  (I(b, c, d)  +  x  +  ac);
        a  =  rotate_left(a, s);
        a  +=  b;
         return  a;
    }

     private   final   void  decode( int  output[],  byte  input[],  int  off,  int  len)  {
         int  i  =   0 ;
         int  j  =   0 ;
         for  (; j   len; i ++ , j  +=   4 )  {
            output[i]  =  ((( int ) (input[off  +  j]  &amp;   0xff ))
                     |  ((( int ) (input[off  +  j  +   1 ]  &amp;   0xff ))  &lt;&lt;&lt;/span&gt;  8 )
                     |  ((( int ) (input[off  +  j  +   2 ]  &amp;   0xff ))  &lt;&lt;&lt;/span&gt;  16) | (((int ) (input[off
                     +  j  +   3 ]  &amp;   0xff ))  &lt;&lt;&lt;/span&gt;  24 ));
        }
    }

     private   final   void  transform( byte  block[],  int  offset)  {
         int  a  =  state[ 0 ];
         int  b  =  state[ 1 ];
         int  c  =  state[ 2 ];
         int  d  =  state[ 3 ];
         int  x[]  =   new   int [ 16 ];

        decode(x, block, offset,  64 );
         /*  Round 1  */
        a  =  FF(a, b, c, d, x[ 0 ], S11,  0xd76aa478 );  /*  1  */
        d  =  FF(d, a, b, c, x[ 1 ], S12,  0xe8c7b756 );  /*  2  */
        c  =  FF(c, d, a, b, x[ 2 ], S13,  0x242070db );  /*  3  */
        b  =  FF(b, c, d, a, x[ 3 ], S14,  0xc1bdceee );  /*  4  */
        a  =  FF(a, b, c, d, x[ 4 ], S11,  0xf57c0faf );  /*  5  */
        d  =  FF(d, a, b, c, x[ 5 ], S12,  0x4787c62a );  /*  6  */
        c  =  FF(c, d, a, b, x[ 6 ], S13,  0xa8304613 );  /*  7  */
        b  =  FF(b, c, d, a, x[ 7 ], S14,  0xfd469501 );  /*  8  */
        a  =  FF(a, b, c, d, x[ 8 ], S11,  0x698098d8 );  /*  9  */
        d  =  FF(d, a, b, c, x[ 9 ], S12,  0x8b44f7af );  /*  10  */
        c  =  FF(c, d, a, b, x[ 10 ], S13,  0xffff5bb1 );  /*  11  */
        b  =  FF(b, c, d, a, x[ 11 ], S14,  0x895cd7be );  /*  12  */
        a  =  FF(a, b, c, d, x[ 12 ], S11,  0x6b901122 );  /*  13  */
        d  =  FF(d, a, b, c, x[ 13 ], S12,  0xfd987193 );  /*  14  */
        c  =  FF(c, d, a, b, x[ 14 ], S13,  0xa679438e );  /*  15  */
        b  =  FF(b, c, d, a, x[ 15 ], S14,  0x49b40821 );  /*  16  */
         /*  Round 2  */
        a  =  GG(a, b, c, d, x[ 1 ], S21,  0xf61e2562 );  /*  17  */
        d  =  GG(d, a, b, c, x[ 6 ], S22,  0xc040b340 );  /*  18  */
        c  =  GG(c, d, a, b, x[ 11 ], S23,  0x265e5a51 );  /*  19  */
        b  =  GG(b, c, d, a, x[ 0 ], S24,  0xe9b6c7aa );  /*  20  */
        a  =  GG(a, b, c, d, x[ 5 ], S21,  0xd62f105d );  /*  21  */
        d  =  GG(d, a, b, c, x[ 10 ], S22,  0x2441453 );  /*  22  */
        c  =  GG(c, d, a, b, x[ 15 ], S23,  0xd8a1e681 );  /*  23  */
        b  =  GG(b, c, d, a, x[ 4 ], S24,  0xe7d3fbc8 );  /*  24  */
        a  =  GG(a, b, c, d, x[ 9 ], S21,  0x21e1cde6 );  /*  25  */
        d  =  GG(d, a, b, c, x[ 14 ], S22,  0xc33707d6 );  /*  26  */
        c  =  GG(c, d, a, b, x[ 3 ], S23,  0xf4d50d87 );  /*  27  */
        b  =  GG(b, c, d, a, x[ 8 ], S24,  0x455a14ed );  /*  28  */
        a  =  GG(a, b, c, d, x[ 13 ], S21,  0xa9e3e905 );  /*  29  */
        d  =  GG(d, a, b, c, x[ 2 ], S22,  0xfcefa3f8 );  /*  30  */
        c  =  GG(c, d, a, b, x[ 7 ], S23,  0x676f02d9 );  /*  31  */
        b  =  GG(b, c, d, a, x[ 12 ], S24,  0x8d2a4c8a );  /*  32  */

         /*  Round 3  */
        a  =  HH(a, b, c, d, x[ 5 ], S31,  0xfffa3942 );  /*  33  */
        d  =  HH(d, a, b, c, x[ 8 ], S32,  0x8771f681 );  /*  34  */
        c  =  HH(c, d, a, b, x[ 11 ], S33,  0x6d9d6122 );  /*  35  */
        b  =  HH(b, c, d, a, x[ 14 ], S34,  0xfde5380c );  /*  36  */
        a  =  HH(a, b, c, d, x[ 1 ], S31,  0xa4beea44 );  /*  37  */
        d  =  HH(d, a, b, c, x[ 4 ], S32,  0x4bdecfa9 );  /*  38  */
        c  =  HH(c, d, a, b, x[ 7 ], S33,  0xf6bb4b60 );  /*  39  */
        b  =  HH(b, c, d, a, x[ 10 ], S34,  0xbebfbc70 );  /*  40  */
        a  =  HH(a, b, c, d, x[ 13 ], S31,  0x289b7ec6 );  /*  41  */
        d  =  HH(d, a, b, c, x[ 0 ], S32,  0xeaa127fa );  /*  42  */
        c  =  HH(c, d, a, b, x[ 3 ], S33,  0xd4ef3085 );  /*  43  */
        b  =  HH(b, c, d, a, x[ 6 ], S34,  0x4881d05 );  /*  44  */
        a  =  HH(a, b, c, d, x[ 9 ], S31,  0xd9d4d039 );  /*  45  */
        d  =  HH(d, a, b, c, x[ 12 ], S32,  0xe6db99e5 );  /*  46  */
        c  =  HH(c, d, a, b, x[ 15 ], S33,  0x1fa27cf8 );  /*  47  */
        b  =  HH(b, c, d, a, x[ 2 ], S34,  0xc4ac5665 );  /*  48  */

         /*  Round 4  */
        a  =  II(a, b, c, d, x[ 0 ], S41,  0xf4292244 );  /*  49  */
        d  =  II(d, a, b, c, x[ 7 ], S42,  0x432aff97 );  /*  50  */
        c  =  II(c, d, a, b, x[ 14 ], S43,  0xab9423a7 );  /*  51  */
        b  =  II(b, c, d, a, x[ 5 ], S44,  0xfc93a039 );  /*  52  */
        a  =  II(a, b, c, d, x[ 12 ], S41,  0x655b59c3 );  /*  53  */
        d  =  II(d, a, b, c, x[ 3 ], S42,  0x8f0ccc92 );  /*  54  */
        c  =  II(c, d, a, b, x[ 10 ], S43,  0xffeff47d );  /*  55  */
        b  =  II(b, c, d, a, x[ 1 ], S44,  0x85845dd1 );  /*  56  */
        a  =  II(a, b, c, d, x[ 8 ], S41,  0x6fa87e4f );  /*  57  */
        d  =  II(d, a, b, c, x[ 15 ], S42,  0xfe2ce6e0 );  /*  58  */
        c  =  II(c, d, a, b, x[ 6 ], S43,  0xa3014314 );  /*  59  */
        b  =  II(b, c, d, a, x[ 13 ], S44,  0x4e0811a1 );  /*  60  */
        a  =  II(a, b, c, d, x[ 4 ], S41,  0xf7537e82 );  /*  61  */
        d  =  II(d, a, b, c, x[ 11 ], S42,  0xbd3af235 );  /*  62  */
        c  =  II(c, d, a, b, x[ 2 ], S43,  0x2ad7d2bb );  /*  63  */
        b  =  II(b, c, d, a, x[ 9 ], S44,  0xeb86d391 );  /*  64  */

        state[ 0 ]  +=  a;
        state[ 1 ]  +=  b;
        state[ 2 ]  +=  c;
        state[ 3 ]  +=  d;
    }

     private   final   void  update( byte  input[],  int  len)  {
         int  index  =  (( int ) (count  &gt;&gt;   3 ))  &amp;   0x3f ;
        count  +=  (len  &lt;&lt;&lt;/span&gt;  3 );
         int  partLen  =   64   -  index;
         int  i  =   0 ;
         if  (len  &gt;=  partLen)  {
            System.arraycopy(input,  0 , buffer, index, partLen);
            transform(buffer,  0 );
             for  (i  =  partLen; i  +   63    len; i  +=   64 )
                transform(input, i);
            index  =   0 ;
        }   else   {
            i  =   0 ;
        }
        System.arraycopy(input, i, buffer, index, len  -  i);
    }

     private   byte [] end()  {
         byte  bits[]  =   new   byte [ 8 ];
         for  ( int  i  =   0 ; i    8 ; i ++ )
            bits[i]  =  ( byte ) ((count  &gt;&gt;&gt;  (i  *   8 ))  &amp;   0xff );
         int  index  =  (( int ) (count  &gt;&gt;   3 ))  &amp;   0x3f ;
         int  padlen  =  (index    56 )  ?  ( 56   -  index) : ( 120   -  index);
        update(padding, padlen);
        update(bits,  8 );
         return  encode(state,  16 );
    }

     //  Encode the content.state array into 16 bytes array
     private   byte [] encode( int  input[],  int  len)  {
         byte  output[]  =   new   byte [len];
         int  i  =   0 ;
         int  j  =   0 ;
         for  (; j   len; i ++ , j  +=   4 )  {
            output[j]  =  ( byte ) ((input[i])  &amp;   0xff );
            output[j  +   1 ]  =  ( byte ) ((input[i]  &gt;&gt;   8 )  &amp;   0xff );
            output[j  +   2 ]  =  ( byte ) ((input[i]  &gt;&gt;   16 )  &amp;   0xff );
            output[j  +   3 ]  =  ( byte ) ((input[i]  &gt;&gt;   24 )  &amp;   0xff );
        }
         return  output;
    }

     /**
     * Get the digest for our input stream. This method constructs the input
     * stream digest, and return it, as a a String, following the MD5 (rfc1321)
     * algorithm,
     * 
     *  @return  An instance of String, giving the message digest.
     *  @exception  IOException
     *                Thrown if the digestifier was unable to read the input
     *                stream.
      */

     public   byte [] getDigest()  throws  IOException  {
         byte  buffer[]  =   new   byte [BUFFER_SIZE];
         int  got  =   - 1 ;

         if  (digest  !=   null )
             return  digest;
         while  ((got  =  in.read(buffer))  &gt;   0 )
            update(buffer, got);
         this .digest  =  end();
         return  digest;
    }

     /**
     * Get the digest, for this string digestifier. This method doesn't throw
     * any IOException, since it knows that the underlying stream ws built from
     * a String.
      */

     public   byte [] processString()  {
         if  ( ! stringp)
             throw   new  RuntimeException( this .getClass().getName()
                     +   " [processString] "   +   "  not a string. " );
         try   {
             return  getDigest();
        }   catch  (IOException ex)  {
        }
         throw   new  RuntimeException( this .getClass().getName()
                 +   " [processString] "   +   " : implementation error. " );
    }

     /**
     * Get the digest, as a proper string.
      */

     public  String getStringDigest()  {
         if  (digest  ==   null )
             throw   new  RuntimeException( this .getClass().getName()
                     +   " [getStringDigest] "   +   " : called before processing. " );
         return  stringify(digest);
    }

     /**
     * Construct a digestifier for the given string.
     * 
     *  @param  input
     *            The string to be digestified.
     *  @param  encoding
     *            the encoding name used (such as UTF8)
      */

     public  MD5(String input, String enc)  {
         byte  bytes[]  =   null ;
         try   {
            bytes  =  input.getBytes(enc);
        }   catch  (UnsupportedEncodingException e)  {
             throw   new  RuntimeException( " no  "   +  enc  +   "  encoding!!! " );
        }
         this .stringp  =   true ;
         this .in  =   new  ByteArrayInputStream(bytes);
         this .state  =   new   int [ 4 ];
         this .buffer  =   new   byte [ 64 ];
         this .count  =   0 ;
        state[ 0 ]  =   0x67452301 ;
        state[ 1 ]  =   0xefcdab89 ;
        state[ 2 ]  =   0x98badcfe ;
        state[ 3 ]  =   0x10325476 ;
    }

     /**
     * Construct a digestifier for the given string.
     * 
     *  @param  input
     *            The string to be digestified.
      */

     public  MD5(String input)  {
         this (input,  " UTF8 " );
    }

     /**
     * Construct a digestifier for the given input stream.
     * 
     *  @param  in
     *            The input stream to be digestified.
      */

     public  MD5(InputStream in)  {
         this .stringp  =   false ;
         this .in  =  in;
         this .state  =   new   int [ 4 ];
         this .buffer  =   new   byte [ 64 ];
         this .count  =   0 ;
        state[ 0 ]  =   0x67452301 ;
        state[ 1 ]  =   0xefcdab89 ;
        state[ 2 ]  =   0x98badcfe ;
        state[ 3 ]  =   0x10325476 ;
    }

     public   static   void  main(String args[])  throws  IOException  {
         if  (args.length  !=   1 )  {
            System.out.println( " Md5  " );
            System.exit( 1 );
        }
        MD5 md5  =   new  MD5( new  FileInputStream( new  File(args[ 0 ])));
         byte  b[]  =  md5.getDigest();
        System.out.println(stringify(b));
    }

} 
</code></pre>
]]></content>
  </entry>
  
</feed>
