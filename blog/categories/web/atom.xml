<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web | zJun's Notes]]></title>
  <link href="http://zjun.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://zjun.github.io/"/>
  <updated>2014-10-26T17:33:45+08:00</updated>
  <id>http://zjun.github.io/</id>
  <author>
    <name><![CDATA[zJun]]></name>
    <email><![CDATA[zjun101@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dojo在IE中的那些坑]]></title>
    <link href="http://zjun.github.io/blog/2013/05/14/dojo-traps-in-ie/"/>
    <updated>2013-05-14T17:37:00+08:00</updated>
    <id>http://zjun.github.io/blog/2013/05/14/dojo-traps-in-ie</id>
    <content type="html"><![CDATA[<p>最近的一个小项目中使用的<a href="http://dojotoolkit.org/">dojo</a>作为前台页面框架。本来很简单的功能，但是发布给用户做  UAT时却发现一堆简单低级的错误，但在开发环境却始终不能重现，百思不得其解&hellip;原来用户的测试环境是 IE8，果然问题在这，之前测试是在FireFox，没想到相同的功能在IE中却报错。</p>

<!-- more -->


<h3>坑一：</h3>

<ul>
<li>症状：页面上普通按钮，在IE中确实始终会默认submit页面。</li>
<li><p>原因：在<a href="http://zhidao.baidu.com/question/531818487.html">这里</a>找到类似的问题：</p>

<blockquote><p>button元素的默认type属性的值为submit，这个是标准，和IE版本没关系。如果不喜欢可以直接用&lt; input type=&lsquo;button&rsquo;>代替。</p></blockquote></li>
<li><p>解决方案：在 button 强制加上 type=&lsquo;button&rsquo; 属性</p>

<pre><code>  &lt; button data-dojo-type="dijit.form.Button" type='button'&gt;  
     Add  
  &lt; script type="dojo/method" data-dojo-event="onClick" data-dojo-args="evt"&gt;  
     add()  
  &lt; /script&gt;    
  &lt; /button&gt;
</code></pre></li>
</ul>


<h3>坑二：</h3>

<ul>
<li>症状：在datagrid上做了 inline edit后，保存后数据不会刷新，总是更改前的就数据</li>
<li>原因： datagrid的data store默认是使用了cache,这在FireFox中是不会引起问题的，但在IE中就不能刷新数据。</li>
<li>解决方案：在datagrid中不使用缓存：
      var store= new dojo.data.ItemFileWriteStore({
          url : &lsquo;&lt;c:url value=&ldquo;/billitem.wss?method=modifiedListStore&amp;selectId=${selectId}&rdquo; />&rsquo;,
          requestMethod:&ldquo;post&rdquo;,
          urlPreventCache:true}
      );</li>
</ul>


<h3>坑三：</h3>

<ul>
<li>症状：datagrid中最后修改的cell里的值总是不能保存到数据库</li>
<li>原因：datagrid是通过onApplyCellEdit事件将未保存的修改数据save到itemStore.<em>pending(</em>newItem，<em>modifiedItems, </em>removedItems).但是onApplyCellEdit是通过Enter或者blur触发的，在FireFox中当用户点击当前cell以外的任意页面都会触发这个事件，但是在IE中必须要点击datagrid的其他地方才能触发，否则不会（比如：点击grid以外的save按钮）。</li>
<li>解决方案：google了一下午，最后在<a href="http://dojo-toolkit.33424.n3.nabble.com/DataGrid-last-edited-cell-does-not-save-td2358868.html">这里</a>找到解决办法：

<blockquote><p>this is a known problem, I think.  Well at least I&rsquo;ve known about it for
a while lol. I&rsquo;m lazy so I never bothered to check for a bug on it. I
always figured that I could manually trigger lost focus or something on
the cell to get it to set the value to the store.</p></blockquote>

<pre><code>  &lt; table dojoType="dojox.grid.DataGrid" onBlur="onTableBlur"&gt;---&lt; /table&gt;

  function onTableBlur()
  {
    if (this.edit.isEditing())
      this.edit.apply();
  } 
</code></pre></li>
</ul>


<h3>参考资料：</h3>

<ul>
<li><a href="http://dojo-toolkit.33424.n3.nabble.com/DataGrid-last-edited-cell-does-not-save-td2358868.html">DataGrid last edited cell does not save</a></li>
<li><a href="http://stackoverflow.com/questions/12616974/event-not-firing-for-dojos-datagrid">Event not firing for dojo&rsquo;s DataGrid</a></li>
<li><a href="http://zhidao.baidu.com/question/531818487.html">html中button自动提交表单问题!</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HighCharts 笔记2：通过表格生成Pie Chart]]></title>
    <link href="http://zjun.github.io/blog/2013/04/01/highcharts-2-piechart/"/>
    <updated>2013-04-01T15:49:00+08:00</updated>
    <id>http://zjun.github.io/blog/2013/04/01/highcharts-2-piechart</id>
    <content type="html"><![CDATA[<p>接上一篇 <a href="http://zjun.github.com/2013/03/28/highcharts-json-dataformat/">HighCharts笔记之: Bar Chart</a>，这一篇继续记录在项目中使用 Pie Chart 的情况,只是自己的一点总结和记录，以备日后翻阅。这一次是通过页面上的表格(Table)数据，生成对应的饼图（Pie Chart），具体实现如下：</p>

<blockquote><p><strong>Highcharts</strong> 是一个用纯JavaScript编写的一个图表库, 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，并且免费提供给个人学习、个人网站和非商业用途使用。目前HighCharts支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。
HighCharts界面美观，由于使用JavaScript编写，所以不需要像Flash和Java那样需要插件才可以运行，而且运行速度快。另外HighCharts还有很好的兼容性，能够完美支持当前大多数浏览器。</p></blockquote>

<!-- more -->


<h3>Pie Chart</h3>

<p><img src="http://farm9.staticflickr.com/8539/8609442562_2945899e60.jpg" alt="" /></p>

<h3>HTML Code</h3>

<pre><code>&lt;body&gt;

    &lt;div class="modal-header"&gt;
        &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;×&lt;/button&gt;
        &lt;h3 id="myModalLabel"&gt;${title}&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
        &lt;div id="container2" style="width: 100%; height: 280px"&gt;&lt;/div&gt;

        &lt;table id="datatable" class="table table-striped table-bordered table-hover table-condensed"&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                     &lt;th&gt;User&lt;/th&gt;
                     &lt;th&gt;${title}&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;c:forEach items="${userSum}" var="item"&gt;
                &lt;tr&gt;
                    &lt;th&gt;${item.user }&lt;/th&gt;
                    &lt;td&gt;${item.sum }&lt;/td&gt;
                &lt;/tr&gt;
                &lt;/c:forEach&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
        &lt;button class="btn" data-dismiss="modal" aria-hidden="true"&gt;Close&lt;/button&gt;
    &lt;/div&gt;

&lt;/body&gt;
</code></pre>

<h3>Javascript Code</h3>

<pre><code>var chart;
Highcharts.visualize = function(table, options) {

    // the data series
    options.series = [];
    var l= options.series.length; 
    options.series[l] = {
      name: '${title}',
      data: []
    };

    $('tbody tr', table).each( function(i) {
        var tr = this;
        var th = $('th', tr).text();
        var td =parseFloat($('td', tr).text());
        options.series[0].data.push({name:th,y:td});
    });
    chart = new Highcharts.Chart(options);
}

// On document ready, call visualize on the datatable.
$(document).ready(function() {         
   var table = document.getElementById('datatable'),
   options = {
         chart: {
            renderTo: 'container2',
            defaultSeriesType: 'pie'
         },
         title: {
            text: '${title}'
         },
         tooltip: {
            formatter: function() {
               return '&lt;b&gt;'+ this.series.name +'&lt;/b&gt;&lt;br/&gt;'+
               this.point.name +' '+ this.y;
            }
         },
         plotOptions: {
             pie: {
                 allowPointSelect: true,
                 cursor: 'pointer'
             }
         }
      };


   Highcharts.visualize(table, options);
});
</code></pre>

<p>这种做法在 Coding 时会更简洁，但在实际运行时效率不高，因为 Pie Chart 需要等待页面上的数据都生成时才能呈现，所以总是给用户一种迟滞感，所以个人感觉还是通过 JSon 的方式生成图表更好（更快）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HighCharts笔记之: Bar Chart]]></title>
    <link href="http://zjun.github.io/blog/2013/03/28/highcharts-json-dataformat/"/>
    <updated>2013-03-28T16:52:00+08:00</updated>
    <id>http://zjun.github.io/blog/2013/03/28/highcharts-json-dataformat</id>
    <content type="html"><![CDATA[<p>最近需要做一些Web图标，研究了几个开源的第三方工具后，最后决定使用<strong>HighCharts</strong>开发：</p>

<p><strong>Highcharts</strong> 是一个用纯JavaScript编写的一个图表库, 能够很简单便捷的在web网站或是web应用程序添加有交互性的图表，并且免费提供给个人学习、个人网站和非商业用途使用。目前HighCharts支持的图表类型有曲线图、区域图、柱状图、饼状图、散状点图和综合图表。
HighCharts界面美观，由于使用JavaScript编写，所以不需要像Flash和Java那样需要插件才可以运行，而且运行速度快。另外HighCharts还有很好的兼容性，能够完美支持当前大多数浏览器。</p>

<p>HighCharts 可以通过JSON 数据格式与后台交互，从而生成动态的图表。但是在官方的文档中关于 JSON 数据格式的资料很少，经过一下午的调试终于找到了关于柱状图和饼图的数据格式，在这里记录一下，以备后续的查询：</p>

<!-- more -->


<h2>柱状图：</h2>

<p><img src="http://farm9.staticflickr.com/8382/8596618053_22114c25cc_b.jpg" alt="" />
JSON Data</p>

<pre><code>[
    {
        "data":[0,0,0,0,0,0,0,0,9,0,0,1],
        "name":"Actual"
    },
    {
        "data":[1,1,1,4,1,1,1,1,12,1,3,6],
        "name":"Target"
    }
]
</code></pre>

<p>Javascript code</p>

<pre><code>&lt;script type="text/javascript"&gt;
    $(function () {
        var options = {
            chart: {

                renderTo: 'container',
                defaultSeriesType: 'bar'
            },
            title: {
                text: ''
            },
            subtitle: {
                text: ''
            },
            xAxis: {
                categories: ['Activity Entry', 'Activity Update', 'Blog Entry', 'Blog Comments', 'Feed','Bookmark','File','Forum Topic','Forum Reply','Wiki','Ram','Liquid'],
                title: {
                    text: null
                }
            },
            yAxis: {
                min: 0,
                title: {
                    text: 'Units',
                    align: 'high'
                },
                labels: {
                    overflow: 'justify'
                }
            },
            tooltip: {
                formatter: function() {
                    return ''+
                        this.series.name +': '+ this.y;
                }
            },
            plotOptions: {
                bar: {
                    dataLabels: {
                        enabled: true
                    }
                }
            },
            legend: {
                layout: 'vertical',
                align: 'right',
                verticalAlign: 'top',
                x: -100,
                y: 100,
                floating: true,
                borderWidth: 1,
                backgroundColor: '#FFFFFF',
                shadow: true
            },
            credits: {
                enabled: false
            },
            series: []
        };

        $.getJSON('&lt;c:url value="/action.do?method=barChart"/&gt;', function(json) {
                options.series = json;//options.series.push(json);  
                //console.log("JSON: " + JSON.stringify(options));
                //console.log("Render to element with ID : " + options.chart.renderTo);
                //console.log("Number of matching dom elements : " + $("#" + options.chart.renderTo).length);
                new Highcharts.Chart(options);
            }).error(function() {console.log('error');});

        $("a[data-toggle=modal]").click(function(){
            var target = $(this).attr('data-target');
            var url = $(this).attr('href');
            $(target).innerHTML='';
            $(target).load(url);
        });    
    });
&lt;/script&gt;  
</code></pre>

<p>HTML</p>

<pre><code>&lt;div id="container" style="width: 100%; height: 400px"&gt;&lt;/div&gt;
</code></pre>

<p>Java Code &ndash; Action</p>

<pre><code>public ActionForward barChart(ActionMapping mapping, ActionForm form,
            HttpServletRequest request, HttpServletResponse response)
            throws IOException {
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json;charset=utf-8");

        List&lt;Bar&gt; resultList = getBarData();
        JSONArray json = new JSONArray(resultList);
        String result = json.toString();// 转成json数据

        PrintWriter out = response.getWriter();
        out.write(result);
        out.flush();
        out.close();

        return null;
    }

    private List&lt;Bar&gt; getBarData() {
        BlueCommunity target = dao.getLatestTarget();
        BlueCommunity actual = dao.sumLatestActual();

        List&lt;Bar&gt; resultList = new ArrayList&lt;Bar&gt;();
        if (actual != null) {
            resultList.add(new Bar("Actual", actual.getValueArray()));
        } else {
            resultList.add(new Bar("Actual", new int[] { 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0 }));
        }
        resultList.add(new Bar("Target", target.getValueArray()));

        return resultList;
}
</code></pre>

<p>Java Code &ndash; Bar class</p>

<pre><code>public class Bar {

    private static final long serialVersionUID = 6461863786317563773L;

    private String name;
    private int[] data;

    public Bar() {
    };

    public Bar(String name, int[] data) {
        this.name = name;
        this.data = data;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int[] getData() {
        return data;
    }

    public void setData(int[] data) {
        this.data = data;
    }

}
</code></pre>

<p>Java Code &ndash; Community class</p>

<pre><code>public class Community implements Serializable {

    private static final long serialVersionUID = -7516165631503337884L;

    private int id;
    private int version;
    private String remark;
    private int activity_entry;
    private int activity_update;
    private int blog_entry;
    private int blog_comments;
    private int feed;
    private int bookmark;
    private int file;
    private int forum_topic;
    private int forum_reply;
    private int wiki;
    private int iRam;
    private int liquid;
    private int user;

    ...
    getters;
    setters;
    ...

    public int[] getValueArray() {
        int[] array = { activity_entry, activity_update, blog_entry,
                blog_comments, feed, bookmark, file, forum_topic, forum_reply,
                wiki, iRam, liquid };
        return array;
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JSP/Servlet中的事件处理]]></title>
    <link href="http://zjun.github.io/blog/2006/07/20/event-in-jsp-servlet/"/>
    <updated>2006-07-20T14:23:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/07/20/event-in-jsp-servlet</id>
    <content type="html"><![CDATA[<p>写过AWT或Swing程序的人一定对桌面程序的事件处理机制印象深刻：通过实现Listener接口的类可以在特定事件(Event)发生时，呼叫特定的方法来对事件进行响应。</p>

<p>其实我们在编写JSP/Servle程序时，也有类似的事件处理机制，所不同的是在JSP/Servlet中是在web.xml中注册Listener，由Container在特定事件发生时呼叫特定的实现Listener的类。</p>

<!-- more -->


<h3>1. Servlet中的Listener和Event:</h3>

<p>在JSP 2.0/Servlet 2.4中，共有八个Listener接口，六个Event类别。</p>

<ul>
<li><strong>ServletContextListener接口</strong></li>
</ul>


<p>[<strong>接口方法</strong>] contextInitialized()与 contextDestroyed()</p>

<p>[<strong>接收事件</strong>] ServletContextEvent</p>

<p>[<strong>触发场景</strong>] 在Container加载Web应用程序时（例如启动 Container之后），会呼叫contextInitialized()，而当容器移除Web应用程序时，会呼叫contextDestroyed ()方法。</p>

<ul>
<li><strong>ServletContextAttributeListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] attributeAdded()、 attributeReplaced()、attributeRemoved()</p>

<p>[<strong>接收事件</strong>] ServletContextAttributeEvent</p>

<p>[<strong>触发场景</strong>] 若有对象加入为application（ServletContext）对象的属性，则会呼叫attributeAdded()，同理在置换属性与移除属性时，会分别呼叫attributeReplaced()、attributeRemoved()。</p>

<ul>
<li><strong>HttpSessionListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] sessionCreated()与sessionDestroyed ()</p>

<p>[<strong>接收事件</strong>] HttpSessionEvent</p>

<p>[<strong>触发场景</strong>] 在session （HttpSession）对象建立或被消灭时，会分别呼叫这两个方法。</p>

<ul>
<li><strong>HttpSessionAttributeListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] attributeAdded()、 attributeReplaced()、attributeRemoved()</p>

<p>[<strong>接收事件</strong>] HttpSessionBindingEvent</p>

<p>[<strong>触发场景</strong>] 若有对象加入为session（HttpSession）对象的属性，则会呼叫attributeAdded()，同理在置换属性与移除属性时，会分别呼叫attributeReplaced()、 attributeRemoved()。</p>

<ul>
<li><strong>HttpSessionActivationListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] sessionDidActivate()与 sessionWillPassivate()</p>

<p>[<strong>接收事件</strong>] HttpSessionEvent</p>

<p>[<strong>触发场景</strong>] Activate与Passivate是用于置换对象的动作，当session对象为了资源利用或负载平衡等原因而必须暂时储存至硬盘或其它储存器时（透过对象序列化），所作的动作称之为Passivate，而硬盘或储存器上的session对象重新加载JVM时所采的动作称之为Activate，所以容易理解的，sessionDidActivate()与 sessionWillPassivate()分别于Activeate后与将Passivate前呼叫。</p>

<ul>
<li><strong>ServletRequestListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] requestInitialized()与 requestDestroyed()</p>

<p>[<strong>接收事件</strong>] RequestEvent</p>

<p>[<strong>触发场景</strong>] 在request（HttpServletRequest）对象建立或被消灭时，会分别呼叫这两个方法。</p>

<ul>
<li><strong>ServletRequestAttributeListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] attributeAdded()、 attributeReplaced()、attributeRemoved()</p>

<p>[<strong>接收事件</strong>] HttpSessionBindingEvent</p>

<p>[<strong>触发场景</strong>] 若有对象加入为request（HttpServletRequest）对象的属性，则会呼叫attributeAdded()，同理在置换属性与移除属性时，会分别呼叫attributeReplaced()、 attributeRemoved()。</p>

<ul>
<li><strong>HttpSessionBindingListener</strong></li>
</ul>


<p>[<strong>接口方法</strong>] valueBound()与valueUnbound()</p>

<p>[<strong>接收事件</strong>] HttpSessionBindingEvent</p>

<p>[<strong>触发场景</strong>] 实现HttpSessionBindingListener接口的类别，其实例如果被加入至session（HttpSession）对象的属性中，则会呼叫 valueBound()，如果被从session（HttpSession）对象的属性中移除，则会呼叫valueUnbound()，实现HttpSessionBindingListener接口的类别不需在web.xml中设定。</p>

<h3>2. 如何注册Servlet中的事件</h3>

<p>实现上面这几个接口的类别，除了HttpSessionBindingListener外,必须在web.xml中向容器注册，容器才会在对应的事件发生时呼叫对应的类别，如：</p>

<pre><code>&lt; listener &gt;  
&lt; listener-class &gt; demo.servlet.listener.CustomServletContextListener &lt;/ listener-class &gt;  
&lt;/ listener &gt;
</code></pre>

<h3>3. Servlet事件的应用实例</h3>

<p>看到这里,你也许会有疑问: 了解这些 listener和event 有什么用呢?我平时开发没有用到这些,一样也能完成任务啊.</p>

<p>不错,在日常的开发中很少用到这些事件处理的方面,但是在某些情况下使用事件处理机制却可以达到事半功倍的效果,例如下面两个例子:</p>

<p><a href="http://www.blogjava.net/javaora/archive/2005/09/12/12760.html">利用HttpSessionListener实现网站在线人数统计功能</a></p>

<p><a href="http://www.blogjava.net/liuwentao253/archive/2006/11/26/83571.html">使用ServletContextListener在服务器启动和关闭时创建和关闭缓存</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在javascript中实现继承关系]]></title>
    <link href="http://zjun.github.io/blog/2006/03/06/inherit-in-javascriot/"/>
    <updated>2006-03-06T19:40:00+08:00</updated>
    <id>http://zjun.github.io/blog/2006/03/06/inherit-in-javascriot</id>
    <content type="html"><![CDATA[<p>意译自KevLinDev上一篇文章，才疏学浅，望指正，英文原文可到<a href="http://www.kevlindev.com/tutorials/javascript/inheritance/">这里</a>查看。</p>

<hr />

<p>javascript脚本语言是支持面向对象编程(Object Oriented Programming )的,只是javascript实现的方式比较特别，与C++和java中的实现方式不同。在javascript中我们需要借助prototype对象来访问父类的方法，下面将讨论在javascript中实现OOP中最基本的特征关系 &mdash;&ndash; <strong>继承</strong>。</p>

<!-- more -->


<h2>首先</h2>

<p>我们从最基本的开始：<strong>在javascript中创建对象</strong>。创建一个对象包括2步：<br/>
1) 创建一个和你想要创建的对象同名的函数(这里可以把这个函数理解为java中的构造函数)；<br/>
2) 通过调用 <strong>new 上面创建的函数名</strong> 的方式创建一个对象实例；
<div>
  <pre><code class='javascript'>// 创建同名函数
function Person(first, last) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.first = first;
this.last  = last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
// 创建实例
var person = new Person(&amp;ldquo;John&amp;rdquo;, &amp;ldquo;Dough&amp;rdquo;);</code></pre>
</div>
</p>

<p>注意：构造函数中的<strong>this</strong>指针指向当前的创建的对象，这与java中的表示是一致的。通过this指针我们可以操作对象的属性。</p>

<h2>然后</h2>

<p>设置对象的方法：
<div>
  <pre><code class='javascript'>Person.prototype.toString() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return this.first + &quot; &quot; + this.last;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
alert( person.toString() ); // displays &amp;ldquo;John Dough&amp;rdquo;
alert( person ); // alert函数将默认调用toString()函数</code></pre>
</div>
</p>

<p>在这里我们用到了javascript中的prototype属性。所有的javascript对象都拥有一个prototype属性，javascript就是通过这个属性来实现继承关系的。具体的实现机制是这样的：<strong>当你访问一个对象的属性时，编译器将先查找对象的属性看有没有匹配的。如果没有找到，将继续查找这个对象的prototype属性所指的对象，看是否存在匹配的属性。如果还是没有找到，编译器将检查当前对象的prototype是否拥有prototype属性，如果有将继续查找下去。以此类推，直到查找完所有的prototype属性</strong>。<br/>
从这个过程不难看出，存在着一个类似于继承的访问链，可以把prototype对象指向我们要继承的父类，以此来访问父类的方法。</p>

<h2>接下来</h2>

<p>我们新建一个类Employee来继承上面的Person类，并且新增一个属性id,在Employee的构造函数中只是初始化属性id，而父类中的属性将由Person的构造函数类设置：<br/>
<div>
  <pre><code class='javascript'>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(first, last) {
    if ( arguments.length &amp;gt; 0 )
        this.init(first, last);
}

Person.prototype.init = function(first, last) {
    this.first = first;
    this.last  = last;
}

Employee.prototype = new Person();
Employee.prototype.constructor = Employee;
Employee.superclass = Person.prototype;

function Employee(first, last, id) {
    if ( arguments.length &amp;gt; 0 )
        this.init(first, last, id);
}

Employee.prototype.init = function(first, last, id) {    
    // Call superclass method
    Employee.superclass.init.call(this, first, last);

    // init properties
    this.id = id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>

<p>可以看到，我们把初始化属性的操作提取出来放到了一个init函数中，这样做是为了方便在子类中调用。注意其中的"<strong>Employee.superclass = Person.prototype;</strong>&ldquo;，这里是一个技巧，方便下面在子类中调用父类的方法。<br/>
另一个需要注意的地方是&rdquo;<strong>Employee.superclass.init.call(this, first, last);</strong>&ldquo;:对于所有对象中的方法来说，都可以通过两个方法来调用－－&rdquo;<strong>call</strong>&ldquo; 和 &rdquo;<strong>apply</strong>&ldquo;.<br/>
这里使用了<strong>call</strong>方法，其中第一个参数是将在调用的方法中访问的对象，后面的参数与调用方法的参数一致。<br/>
 <strong>apply</strong>方法的使用与call大致一致，不同在于除了第一个参数外，后面是一个参数数组。</p>

<p>下面附上完整的例子和类图：</p>

<p><strong>继承关系图</strong>如下：<br/>
<img src="http://www.blogjava.net/images/blogjava_net/zjun/8140/o_javascriptOOP.gif" alt="" /></p>

<p><strong>代码</strong>：</p>

<p><div>
  <pre><code class='javascript'>&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*****
*
*    Person constructor
*
*****/
function Person(first, last) {
    if ( arguments.length &amp;gt; 0 )
        this.init(first, last);
}

/*****
*
*    Person init
*
*****/
Person.prototype.init = function(first, last) {
    this.first = first;
    this.last  = last;
};

/*****
*
*    Person toString
*
*****/
Person.prototype.toString = function() {
    return this.first + &quot;,&quot; + this.last;
};


/*****
*
*    Setup Employee inheritance
*
*****/
Employee.prototype = new Person();
Employee.prototype.constructor = Employee;
Employee.superclass = Person.prototype;

/*****
*
*    Employee constructor
*
*****/
function Employee(first, last, id) {
    if ( arguments.length &amp;gt; 0 )
        this.init(first, last, id);
}

/*****
*
*    Employee init
*
*****/
Employee.prototype.init = function(first, last, id) {    
    // Call superclass method
    Employee.superclass.init.call(this, first, last);

    // init properties
    this.id = id;
}

/*****
*
*    Employee toString
*
*****/
Employee.prototype.toString = function() {
    var name = Employee.superclass.toString.call(this);

    return this.id + &quot;:&quot; + name;
};


/*****
*
*    Setup Manager inheritance
*
*****/
Manager.prototype = new Employee;
Manager.prototype.constructor = Manager;
Manager.superclass = Employee.prototype;

/*****
*
*    Manager constructor
*
*****/
function Manager(first, last, id, department) {
    if ( arguments.length &amp;gt; 0 )
        this.init(first, last, id, department);
}

/*****
*
*    Manager init
*
*****/
Manager.prototype.init = function(first, last, id, department){
    // Call superclass method
    Manager.superclass.init.call(this, first, last, id);

    // init properties
    this.department = department;
}

/*****
*
*    Manager toString
*
*****/
Manager.prototype.toString = function() {
    var employee = Manager.superclass.toString.call(this);

    return employee + &quot; manages &quot; + this.department;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;</code></pre>
</div>
</p>
]]></content>
  </entry>
  
</feed>
