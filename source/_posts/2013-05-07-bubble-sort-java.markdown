---
layout: post
title: "冒泡排序"
date: 2006-07-10 11:35
comments: true
external-url: 
categories: 数据结构
---

冒泡排序, 顾名思义，就是排序时，最大的元素会如同气泡一样移至右端，其利用比较相邻元素的方法，将大的元素交换至右端，所以大的元素会不断的往右移动，直到适当的位置为止。
<!-- more -->

基本的气泡排序法可以利用旗标的方式稍微减少一些比较的时间，当寻访完数组后都没有发生任何的交换动作，表示排序已经完成，而无需再进行之后的循环比较与交换动作，例如：

排序前：    95, 27, 90, 49, 80, 58, 6, 9, 18, 50  

第 1 次排序：27 90 49 80 58 6 9 18 50 **95**   
第 2 次排序：27 49 80 58 6 9 18 50 **90** 95   
第 3 次排序：27 49 58 6 9 18 50 **80** 90 95   
第 4 次排序：27 49 6 9 18 50 **58** 80 90 95   
第 5 次排序：27 6 9 18 **49** 50 58 80 90 95   
第 6 次排序：6 9 18 **27** 49 50 58 80 90 95   
第 7 次排序：6 9 18 27 49 50 58 80 90 95  -- 没有改变次序,排序完成  

**Java代码实现：**  
	/*  *
	  * 冒泡排序  
	  * @param data：等待排序整型数组  
	  *     data = { 95, 27, 90, 49, 80, 58, 6, 9, 18, 50 }  
	  *    排序结果：  
	  *        第 1 次排序：27 90 49 80 58 6 9 18 50 95   
	  *        第 2 次排序：27 49 80 58 6 9 18 50 90 95   
	  *        第 3 次排序：27 49 58 6 9 18 50 80 90 95   
	  *        第 4 次排序：27 49 6 9 18 50 58 80 90 95   
	  *        第 5 次排序：27 6 9 18 49 50 58 80 90 95   
	  *        第 6 次排序：6 9 18 27 49 50 58 80 90 95   
	  *        第 7 次排序：6 9 18 27 49 50 58 80 90 95   
	    */   
	    public   void  sort( int [] data)  {  
	         int  max  =  data.length;  
	         boolean  hasChange  =   true ;  
	         for  ( int  i  =   0 ; i  <  max  -   1   &&  hasChange; i ++ )  {  
	            hasChange  =   false ;  
	             for  ( int  j  =   0 ; j  <  max  -  i  -   1 ; j ++ )  {  
	                 if  (data[j  +   1 ]  <  data[j])  {  
	                     int  temp  =  data[j];  
	                    data[j]  =  data[j  +   1 ];  
	                    data[j  +   1 ]  =  temp;  
	                    hasChange  =   true ;  
	                }  
	            }  
	            System.out.print( "  第   "   +  (i  +   1 )  +   "   次排序：  " );  
	             for  ( int  k  =   0 ; k  <=  max  -   1 ; k ++ )  {  
	                System.out.print(data[k]  +   "     " );  
	            }  
	            System.out.println();  
	        }  
	    }  
